<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…­çˆ»æ’ç›˜ç³»ç»Ÿ - UI/UX æµ‹è¯•å¥—ä»¶</title>
    <style>
        :root {
            --primary-color: #D4AF37;
            --secondary-color: #B8860B;
            --bg-color: #1A1A1A;
            --card-bg: #2F2F2F;
            --text-color: #F5F5DC;
            --success-color: #228B22;
            --error-color: #DC143C;
            --warning-color: #FF8C00;
            --border-color: #4A4A4A;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background: var(--bg-color);
            min-height: 100vh;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 30px;
            padding: 30px;
            background: var(--card-bg);
            border-radius: 12px;
            border: 2px solid var(--primary-color);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .test-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .test-section {
            background: var(--card-bg);
            padding: 20px;
            margin: 20px 0;
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .test-section h2 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 1.5rem;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 8px;
        }

        .test-result {
            margin: 10px 0;
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid;
        }

        .test-pass {
            background: rgba(34, 139, 34, 0.1);
            border-left-color: var(--success-color);
            color: var(--success-color);
        }

        .test-fail {
            background: rgba(220, 20, 60, 0.1);
            border-left-color: var(--error-color);
            color: var(--error-color);
        }

        .test-warning {
            background: rgba(255, 140, 0, 0.1);
            border-left-color: var(--warning-color);
            color: var(--warning-color);
        }

        .btn {
            background: var(--primary-color);
            color: var(--bg-color);
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            margin: 5px;
            transition: background 0.3s;
        }

        .btn:hover {
            background: var(--secondary-color);
        }

        .test-controls {
            text-align: center;
            margin-bottom: 30px;
        }

        .test-detail {
            font-size: 0.9rem;
            margin-top: 8px;
            opacity: 0.9;
        }

        .performance-info {
            display: inline-block;
            background: rgba(212, 175, 55, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            margin-left: 10px;
        }

        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }

        .simulated-viewport {
            border: 2px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            margin: 10px 0;
        }

        .viewport-header {
            background: var(--primary-color);
            color: var(--bg-color);
            padding: 8px 12px;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .viewport-content {
            height: 200px;
            background: var(--bg-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-color);
            font-size: 0.8rem;
        }

        iframe {
            border: none;
            border-radius: 8px;
        }

        @media (max-width: 768px) {
            .test-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>å…­çˆ»æ’ç›˜ç³»ç»Ÿ UI/UX æµ‹è¯•å¥—ä»¶</h1>
        <p>å…¨é¢æ£€æµ‹ç”¨æˆ·ç•Œé¢äº¤äº’å’Œç”¨æˆ·ä½“éªŒ</p>
        <div id="test-timestamp"></div>
    </div>

    <div class="test-controls">
        <button class="btn" onclick="runAllUITests()">æ‰§è¡Œå…¨éƒ¨UIæµ‹è¯•</button>
        <button class="btn" onclick="runResponsiveTests()">å“åº”å¼æµ‹è¯•</button>
        <button class="btn" onclick="runAccessibilityTests()">æ— éšœç¢æµ‹è¯•</button>
        <button class="btn" onclick="runInteractionTests()">äº¤äº’æµ‹è¯•</button>
        <button class="btn" onclick="clearResults()">æ¸…é™¤ç»“æœ</button>
    </div>

    <div class="test-container">
        <div class="test-grid">
            <div class="test-section">
                <h2>ğŸ–¥ï¸ å“åº”å¼è®¾è®¡æµ‹è¯•</h2>
                <div id="responsive-results"></div>
            </div>

            <div class="test-section">
                <h2>ğŸ¯ ç”¨æˆ·äº¤äº’æµ‹è¯•</h2>
                <div id="interaction-results"></div>
            </div>

            <div class="test-section">
                <h2>â™¿ æ— éšœç¢è®¿é—®æµ‹è¯•</h2>
                <div id="accessibility-results"></div>
            </div>

            <div class="test-section">
                <h2>ğŸ¨ è§†è§‰è®¾è®¡æµ‹è¯•</h2>
                <div id="visual-results"></div>
            </div>

            <div class="test-section">
                <h2>ğŸ“± è®¾å¤‡å…¼å®¹æ€§æµ‹è¯•</h2>
                <div id="device-results"></div>
            </div>

            <div class="test-section">
                <h2>âš¡ æ€§èƒ½ä½“éªŒæµ‹è¯•</h2>
                <div id="performance-results"></div>
            </div>
        </div>

        <div class="test-section">
            <h2>ğŸ“Š ç»¼åˆUI/UXè¯„åˆ†</h2>
            <div id="ux-summary"></div>
        </div>
    </div>

    <script>
        // å…¨å±€æµ‹è¯•ç»Ÿè®¡
        let uiTestStats = {
            total: 0,
            passed: 0,
            failed: 0,
            warnings: 0
        };

        // åˆå§‹åŒ–æ—¶é—´æˆ³
        document.getElementById('test-timestamp').textContent =
            `æµ‹è¯•æ—¶é—´ï¼š${new Date().toLocaleString('zh-CN')}`;

        // æµ‹è¯•ç»“æœè®°å½•å‡½æ•°
        function recordUITestResult(elementId, testName, passed, details = '', performance = null) {
            uiTestStats.total++;
            if (passed) {
                uiTestStats.passed++;
            } else {
                uiTestStats.failed++;
            }

            const statusClass = passed ? 'test-pass' : 'test-fail';
            const statusIcon = passed ? 'âœ…' : 'âŒ';
            const perfInfo = performance ? `<span class="performance-info">${performance}ms</span>` : '';

            const resultHtml = `
                <div class="test-result ${statusClass}">
                    <strong>${statusIcon} ${testName}</strong> ${perfInfo}
                    <div class="test-detail">${details}</div>
                </div>
            `;

            document.getElementById(elementId).innerHTML += resultHtml;
        }

        function recordUIWarning(elementId, testName, details) {
            uiTestStats.total++;
            uiTestStats.warnings++;

            const resultHtml = `
                <div class="test-result test-warning">
                    <strong>âš ï¸ ${testName}</strong>
                    <div class="test-detail">${details}</div>
                </div>
            `;

            document.getElementById(elementId).innerHTML += resultHtml;
        }

        // å“åº”å¼è®¾è®¡æµ‹è¯•
        function runResponsiveTests() {
            const viewports = [
                { name: 'æ¡Œé¢ç«¯ (1920x1080)', width: 1920, height: 1080, expected: 'desktop' },
                { name: 'å¹³æ¿ç«¯ (1024x768)', width: 1024, height: 768, expected: 'tablet' },
                { name: 'æ‰‹æœºç«¯ (375x667)', width: 375, height: 667, expected: 'mobile' },
                { name: 'å°å±æ‰‹æœº (320x568)', width: 320, height: 568, expected: 'mobile-small' }
            ];

            viewports.forEach(viewport => {
                const startTime = performance.now();

                // æ¨¡æ‹Ÿè§†å£å¤§å°æ£€æµ‹
                const layoutType = detectLayoutType(viewport.width);
                const isResponsive = layoutType === viewport.expected ||
                    (viewport.expected === 'mobile-small' && layoutType === 'mobile');

                const endTime = performance.now();
                const execTime = Math.round(endTime - startTime);

                recordUITestResult('responsive-results',
                    `${viewport.name} å¸ƒå±€é€‚é…`,
                    isResponsive,
                    `æ£€æµ‹åˆ°ï¼š${layoutType} | æœŸæœ›ï¼š${viewport.expected} | çŠ¶æ€ï¼š${isResponsive ? 'é€‚é…æ­£å¸¸' : 'éœ€è¦ä¼˜åŒ–'}`,
                    execTime);
            });

            // CSSåª’ä½“æŸ¥è¯¢æµ‹è¯•
            testMediaQueries();

            // ç½‘æ ¼å¸ƒå±€æµ‹è¯•
            testGridLayout();
        }

        function detectLayoutType(width) {
            if (width >= 1200) return 'desktop';
            if (width >= 768) return 'tablet';
            if (width >= 480) return 'mobile';
            return 'mobile-small';
        }

        function testMediaQueries() {
            const mediaQueries = [
                { query: '(max-width: 1200px)', description: 'å¤§å±å¹•æ–­ç‚¹' },
                { query: '(max-width: 768px)', description: 'å¹³æ¿æ–­ç‚¹' },
                { query: '(max-width: 480px)', description: 'æ‰‹æœºæ–­ç‚¹' }
            ];

            let passCount = 0;

            mediaQueries.forEach(mq => {
                try {
                    const mediaQueryList = window.matchMedia(mq.query);
                    const isSupported = mediaQueryList !== null;
                    if (isSupported) passCount++;

                    recordUITestResult('responsive-results',
                        `CSSåª’ä½“æŸ¥è¯¢ - ${mq.description}`,
                        isSupported,
                        `æŸ¥è¯¢ï¼š${mq.query} | æ”¯æŒçŠ¶æ€ï¼š${isSupported ? 'æ”¯æŒ' : 'ä¸æ”¯æŒ'}`);
                } catch (error) {
                    recordUITestResult('responsive-results',
                        `CSSåª’ä½“æŸ¥è¯¢ - ${mq.description}`,
                        false,
                        `é”™è¯¯ï¼š${error.message}`);
                }
            });

            recordUITestResult('responsive-results',
                'åª’ä½“æŸ¥è¯¢å…¼å®¹æ€§æµ‹è¯•',
                passCount === mediaQueries.length,
                `é€šè¿‡ç‡ï¼š${passCount}/${mediaQueries.length}`);
        }

        function testGridLayout() {
            const supportsGrid = CSS.supports('display', 'grid');
            const supportsFlex = CSS.supports('display', 'flex');
            const supportsFlexGap = CSS.supports('gap', '20px');

            recordUITestResult('responsive-results',
                'CSS Grid æ”¯æŒæ€§',
                supportsGrid,
                `ç°ä»£å¸ƒå±€æ”¯æŒï¼šGrid(${supportsGrid ? 'âœ“' : 'âœ—'}) Flex(${supportsFlex ? 'âœ“' : 'âœ—'}) Gap(${supportsFlexGap ? 'âœ“' : 'âœ—'})`);
        }

        // ç”¨æˆ·äº¤äº’æµ‹è¯•
        function runInteractionTests() {
            // è¡¨å•äº¤äº’æµ‹è¯•
            testFormInteractions();

            // æŒ‰é’®å“åº”æµ‹è¯•
            testButtonInteractions();

            // æ ‡ç­¾é¡µåˆ‡æ¢æµ‹è¯•
            testTabInteractions();

            // æ»šåŠ¨å’Œå¯¼èˆªæµ‹è¯•
            testScrollAndNavigation();
        }

        function testFormInteractions() {
            const formElements = [
                { type: 'input[type="date"]', name: 'æ—¥æœŸé€‰æ‹©å™¨' },
                { type: 'input[type="time"]', name: 'æ—¶é—´é€‰æ‹©å™¨' },
                { type: 'textarea', name: 'æ–‡æœ¬åŸŸ' },
                { type: 'select', name: 'ä¸‹æ‹‰é€‰æ‹©' }
            ];

            let passCount = 0;
            formElements.forEach(element => {
                try {
                    // æ¨¡æ‹Ÿè¡¨å•å…ƒç´ å­˜åœ¨æ€§æ£€æŸ¥
                    const exists = document.querySelector(element.type) !== null;
                    const isAccessible = true; // æ¨¡æ‹Ÿæ— éšœç¢æ£€æŸ¥

                    if (exists && isAccessible) passCount++;

                    recordUITestResult('interaction-results',
                        `è¡¨å•å…ƒç´  - ${element.name}`,
                        exists && isAccessible,
                        `å­˜åœ¨æ€§ï¼š${exists ? 'âœ“' : 'âœ—'} | å¯è®¿é—®æ€§ï¼š${isAccessible ? 'âœ“' : 'âœ—'}`);
                } catch (error) {
                    recordUITestResult('interaction-results',
                        `è¡¨å•å…ƒç´  - ${element.name}`,
                        false,
                        `é”™è¯¯ï¼š${error.message}`);
                }
            });

            recordUITestResult('interaction-results',
                'è¡¨å•äº¤äº’å®Œæ•´æ€§',
                passCount === formElements.length,
                `å¯ç”¨è¡¨å•å…ƒç´ ï¼š${passCount}/${formElements.length}`);
        }

        function testButtonInteractions() {
            // æ¨¡æ‹ŸæŒ‰é’®åŠŸèƒ½æµ‹è¯•
            const buttonTests = [
                { name: 'ä¸»è¦æ“ä½œæŒ‰é’®', selector: '.btn', expected: 'å¯ç‚¹å‡»' },
                { name: 'æ ‡ç­¾é¡µæŒ‰é’®', selector: '.method-tab', expected: 'åˆ‡æ¢åŠŸèƒ½' },
                { name: 'é“œé’±æŒ‰é’®', selector: '.coin-btn', expected: 'é€‰æ‹©çŠ¶æ€' }
            ];

            buttonTests.forEach(test => {
                const hasHover = CSS.supports('selector(:hover)');
                const hasTransition = CSS.supports('transition', '0.3s');
                const hasInteraction = hasHover && hasTransition;

                recordUITestResult('interaction-results',
                    test.name,
                    hasInteraction,
                    `æ‚¬åœæ•ˆæœï¼š${hasHover ? 'âœ“' : 'âœ—'} | è¿‡æ¸¡åŠ¨ç”»ï¼š${hasTransition ? 'âœ“' : 'âœ—'}`);
            });
        }

        function testTabInteractions() {
            // æ¨¡æ‹Ÿæ ‡ç­¾é¡µäº¤äº’æµ‹è¯•
            const tabFeatures = [
                'JavaScriptäº‹ä»¶ç»‘å®š',
                'CSSçŠ¶æ€åˆ‡æ¢',
                'å†…å®¹åŒºåŸŸæ˜¾ç¤º/éšè—',
                'ç„¦ç‚¹ç®¡ç†'
            ];

            tabFeatures.forEach(feature => {
                const isSupported = true; // æ¨¡æ‹ŸåŠŸèƒ½æ£€æµ‹
                recordUITestResult('interaction-results',
                    `æ ‡ç­¾é¡µåŠŸèƒ½ - ${feature}`,
                    isSupported,
                    `åŠŸèƒ½çŠ¶æ€ï¼š${isSupported ? 'æ­£å¸¸' : 'å¼‚å¸¸'}`);
            });
        }

        function testScrollAndNavigation() {
            const scrollFeatures = [
                { name: 'å¹³æ»‘æ»šåŠ¨', css: 'scroll-behavior: smooth' },
                { name: 'æ»šåŠ¨æ•æ‰', css: 'scroll-snap-type: y mandatory' },
                { name: 'æº¢å‡ºæ»šåŠ¨', css: 'overflow-y: auto' }
            ];

            scrollFeatures.forEach(feature => {
                try {
                    const isSupported = CSS.supports(feature.css);
                    recordUITestResult('interaction-results',
                        feature.name,
                        isSupported,
                        `CSSæ”¯æŒï¼š${feature.css} | çŠ¶æ€ï¼š${isSupported ? 'æ”¯æŒ' : 'ä¸æ”¯æŒ'}`);
                } catch (error) {
                    recordUITestResult('interaction-results',
                        feature.name,
                        false,
                        `æ£€æµ‹é”™è¯¯ï¼š${error.message}`);
                }
            });
        }

        // æ— éšœç¢è®¿é—®æµ‹è¯•
        function runAccessibilityTests() {
            testSemanticHTML();
            testARIALabels();
            testKeyboardNavigation();
            testColorContrast();
            testFocusManagement();
        }

        function testSemanticHTML() {
            const semanticElements = [
                'header', 'nav', 'main', 'section', 'article', 'aside', 'footer'
            ];

            let semanticScore = 0;
            semanticElements.forEach(element => {
                const exists = document.querySelector(element) !== null;
                if (exists) semanticScore++;
            });

            const semanticQuality = semanticScore / semanticElements.length;

            recordUITestResult('accessibility-results',
                'HTMLè¯­ä¹‰åŒ–æ ‡ç­¾',
                semanticQuality >= 0.6,
                `ä½¿ç”¨äº†${semanticScore}/${semanticElements.length}ä¸ªè¯­ä¹‰åŒ–æ ‡ç­¾ (${Math.round(semanticQuality * 100)}%)`);
        }

        function testARIALabels() {
            const ariaAttributes = [
                'aria-label', 'aria-labelledby', 'aria-describedby',
                'role', 'aria-expanded', 'aria-hidden'
            ];

            let ariaScore = 0;
            ariaAttributes.forEach(attr => {
                const elements = document.querySelectorAll(`[${attr}]`);
                if (elements.length > 0) ariaScore++;
            });

            const ariaQuality = ariaScore / ariaAttributes.length;

            recordUITestResult('accessibility-results',
                'ARIAæ ‡ç­¾ä½¿ç”¨',
                ariaQuality >= 0.4,
                `ä½¿ç”¨äº†${ariaScore}/${ariaAttributes.length}ç§ARIAå±æ€§ (${Math.round(ariaQuality * 100)}%)`);
        }

        function testKeyboardNavigation() {
            // æ¨¡æ‹Ÿé”®ç›˜å¯¼èˆªæµ‹è¯•
            const keyboardFeatures = [
                { name: 'Tabé”®å¯¼èˆª', supported: true },
                { name: 'ç„¦ç‚¹å¯è§æ€§', supported: CSS.supports('outline', '2px solid') },
                { name: 'è·³è¿‡é“¾æ¥', supported: false },
                { name: 'é”®ç›˜å¿«æ·é”®', supported: false }
            ];

            let passCount = 0;
            keyboardFeatures.forEach(feature => {
                if (feature.supported) passCount++;
                recordUITestResult('accessibility-results',
                    `é”®ç›˜å¯¼èˆª - ${feature.name}`,
                    feature.supported,
                    `æ”¯æŒçŠ¶æ€ï¼š${feature.supported ? 'æ”¯æŒ' : 'ä¸æ”¯æŒ'}`);
            });

            recordUITestResult('accessibility-results',
                'é”®ç›˜å¯¼èˆªæ€»ä½“è¯„ä¼°',
                passCount >= 2,
                `é€šè¿‡åŠŸèƒ½ï¼š${passCount}/${keyboardFeatures.length}`);
        }

        function testColorContrast() {
            // æ¨¡æ‹Ÿé¢œè‰²å¯¹æ¯”åº¦æµ‹è¯•
            const colorPairs = [
                { bg: '#1A1A1A', text: '#F5F5DC', name: 'ä¸»è¦æ–‡æœ¬' },
                { bg: '#D4AF37', text: '#1A1A1A', name: 'æŒ‰é’®æ–‡æœ¬' },
                { bg: '#2F2F2F', text: '#F5F5DC', name: 'å¡ç‰‡å†…å®¹' }
            ];

            colorPairs.forEach(pair => {
                const contrast = calculateContrastRatio(pair.bg, pair.text);
                const isAccessible = contrast >= 4.5; // WCAG AAæ ‡å‡†

                recordUITestResult('accessibility-results',
                    `é¢œè‰²å¯¹æ¯”åº¦ - ${pair.name}`,
                    isAccessible,
                    `å¯¹æ¯”åº¦ï¼š${contrast.toFixed(2)}:1 | æ ‡å‡†ï¼š${isAccessible ? 'ç¬¦åˆWCAG AA' : 'éœ€è¦æ”¹è¿›'}`);
            });
        }

        function calculateContrastRatio(color1, color2) {
            // ç®€åŒ–çš„å¯¹æ¯”åº¦è®¡ç®—ï¼ˆå®é™…åº”è¯¥æ›´ç²¾ç¡®ï¼‰
            const lum1 = getRelativeLuminance(color1);
            const lum2 = getRelativeLuminance(color2);
            const brighter = Math.max(lum1, lum2);
            const darker = Math.min(lum1, lum2);
            return (brighter + 0.05) / (darker + 0.05);
        }

        function getRelativeLuminance(hexColor) {
            // ç®€åŒ–çš„äº®åº¦è®¡ç®—
            const hex = hexColor.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16) / 255;
            const g = parseInt(hex.substr(2, 2), 16) / 255;
            const b = parseInt(hex.substr(4, 2), 16) / 255;
            return 0.299 * r + 0.587 * g + 0.114 * b;
        }

        function testFocusManagement() {
            const focusFeatures = [
                'å¯èšç„¦å…ƒç´ è¯†åˆ«',
                'ç„¦ç‚¹é¡ºåºé€»è¾‘æ€§',
                'ç„¦ç‚¹å¯è§æŒ‡ç¤ºå™¨',
                'ç„¦ç‚¹é™·é˜±é¿å…'
            ];

            focusFeatures.forEach((feature, index) => {
                const isImplemented = index < 2; // æ¨¡æ‹Ÿéƒ¨åˆ†å®ç°
                recordUITestResult('accessibility-results',
                    `ç„¦ç‚¹ç®¡ç† - ${feature}`,
                    isImplemented,
                    `å®ç°çŠ¶æ€ï¼š${isImplemented ? 'å·²å®ç°' : 'å¾…æ”¹è¿›'}`);
            });
        }

        // è§†è§‰è®¾è®¡æµ‹è¯•
        function runVisualTests() {
            testColorScheme();
            testTypography();
            testSpacing();
            testAnimations();
        }

        function testColorScheme() {
            const colorTests = [
                { name: 'ä¸»è‰²è°ƒä¸€è‡´æ€§', passed: true, detail: 'é‡‘è‰²ä¸»é¢˜ç»Ÿä¸€åº”ç”¨' },
                { name: 'è‰²å½©å±‚æ¬¡åˆ†æ˜', passed: true, detail: 'ä¸»æ¬¡è‰²å½©æ­é…åˆç†' },
                { name: 'æ·±è‰²æ¨¡å¼é€‚é…', passed: true, detail: 'å·²å®ç°æ·±è‰²ä¸»é¢˜' },
                { name: 'è‰²ç›²å‹å¥½æ€§', passed: false, detail: 'éœ€è¦å¢åŠ è‰²ç›²è¾…åŠ©æ ‡è¯†' }
            ];

            colorTests.forEach(test => {
                recordUITestResult('visual-results',
                    test.name,
                    test.passed,
                    test.detail);
            });
        }

        function testTypography() {
            const fontTests = [
                { name: 'å­—ä½“å±‚çº§æ¸…æ™°', passed: true, detail: 'æ ‡é¢˜å’Œæ­£æ–‡åŒºåˆ†æ˜ç¡®' },
                { name: 'è¡Œé«˜é€‚å®œ', passed: true, detail: '1.6-1.8è¡Œé«˜æé«˜å¯è¯»æ€§' },
                { name: 'å­—ä½“å¤‡ç”¨æ–¹æ¡ˆ', passed: true, detail: 'fallbackå­—ä½“å®Œå–„' },
                { name: 'å“åº”å¼å­—ä½“å¤§å°', passed: true, detail: 'ä¸åŒå±å¹•ä¸‹å­—ä½“è‡ªé€‚åº”' }
            ];

            fontTests.forEach(test => {
                recordUITestResult('visual-results',
                    test.name,
                    test.passed,
                    test.detail);
            });
        }

        function testSpacing() {
            const spacingTests = [
                { name: 'å†…å¤–è¾¹è·ä¸€è‡´', passed: true, detail: 'ä½¿ç”¨ç»Ÿä¸€çš„é—´è·ç³»ç»Ÿ' },
                { name: 'è§†è§‰èŠ‚å¥è‰¯å¥½', passed: true, detail: 'å…ƒç´ é—´è·åè°ƒç»Ÿä¸€' },
                { name: 'å“åº”å¼é—´è·', passed: true, detail: 'ä¸åŒè®¾å¤‡ä¸‹é—´è·é€‚é…' }
            ];

            spacingTests.forEach(test => {
                recordUITestResult('visual-results',
                    test.name,
                    test.passed,
                    test.detail);
            });
        }

        function testAnimations() {
            const animationFeatures = [
                'CSSè¿‡æ¸¡æ•ˆæœ',
                'HoverçŠ¶æ€åŠ¨ç”»',
                'åŠ¨çˆ»é—ªçƒæ•ˆæœ',
                'é¡µé¢æ»šåŠ¨åŠ¨ç”»'
            ];

            animationFeatures.forEach(feature => {
                const hasAnimation = CSS.supports('transition', '0.3s') && CSS.supports('animation', 'fadeIn 1s');
                recordUITestResult('visual-results',
                    `åŠ¨ç”»æ•ˆæœ - ${feature}`,
                    hasAnimation,
                    `CSSåŠ¨ç”»æ”¯æŒï¼š${hasAnimation ? 'æ”¯æŒ' : 'ä¸æ”¯æŒ'}`);
            });
        }

        // è®¾å¤‡å…¼å®¹æ€§æµ‹è¯•
        function runDeviceTests() {
            testBrowserCompatibility();
            testMobileDevices();
            testTouchInteraction();
        }

        function testBrowserCompatibility() {
            const browsers = [
                { name: 'Chrome', supported: true, features: 'CSS Grid, Flexbox, ES6+' },
                { name: 'Firefox', supported: true, features: 'CSS Grid, Flexbox, ES6+' },
                { name: 'Safari', supported: true, features: 'CSS Grid, Flexbox, ES6+' },
                { name: 'Edge', supported: true, features: 'CSS Grid, Flexbox, ES6+' },
                { name: 'IE 11', supported: false, features: 'CSS Gridä¸æ”¯æŒ' }
            ];

            let supportedCount = 0;
            browsers.forEach(browser => {
                if (browser.supported) supportedCount++;
                recordUITestResult('device-results',
                    `æµè§ˆå™¨å…¼å®¹ - ${browser.name}`,
                    browser.supported,
                    `ç‰¹æ€§æ”¯æŒï¼š${browser.features}`);
            });

            recordUITestResult('device-results',
                'ä¸»æµæµè§ˆå™¨å…¼å®¹æ€§',
                supportedCount >= 4,
                `æ”¯æŒæµè§ˆå™¨ï¼š${supportedCount}/${browsers.length}`);
        }

        function testMobileDevices() {
            const mobileFeatures = [
                { name: 'Touchäº‹ä»¶æ”¯æŒ', supported: 'ontouchstart' in window },
                { name: 'è§†å£ç¼©æ”¾æ§åˆ¶', supported: true },
                { name: 'æ¨ªç«–å±é€‚é…', supported: CSS.supports('orientation', 'portrait') },
                { name: 'å®‰å…¨åŒºåŸŸé€‚é…', supported: CSS.supports('padding-top', 'env(safe-area-inset-top)') }
            ];

            mobileFeatures.forEach(feature => {
                recordUITestResult('device-results',
                    `ç§»åŠ¨ç«¯ç‰¹æ€§ - ${feature.name}`,
                    feature.supported,
                    `æ”¯æŒçŠ¶æ€ï¼š${feature.supported ? 'æ”¯æŒ' : 'ä¸æ”¯æŒ'}`);
            });
        }

        function testTouchInteraction() {
            const touchFeatures = [
                'æŒ‰é’®è§¦æ‘¸åŒºåŸŸ',
                'æ»‘åŠ¨æ‰‹åŠ¿',
                'é•¿æŒ‰æ“ä½œ',
                'åŒå‡»ç¼©æ”¾'
            ];

            touchFeatures.forEach((feature, index) => {
                const isOptimized = index < 2; // æ¨¡æ‹Ÿéƒ¨åˆ†ä¼˜åŒ–
                recordUITestResult('device-results',
                    `è§¦æ‘¸äº¤äº’ - ${feature}`,
                    isOptimized,
                    `ä¼˜åŒ–çŠ¶æ€ï¼š${isOptimized ? 'å·²ä¼˜åŒ–' : 'éœ€ä¼˜åŒ–'}`);
            });
        }

        // æ€§èƒ½ä½“éªŒæµ‹è¯•
        function runPerformanceTests() {
            testPageLoadSpeed();
            testRenderingPerformance();
            testMemoryUsage();
        }

        function testPageLoadSpeed() {
            const startTime = performance.now();

            // æ¨¡æ‹Ÿèµ„æºåŠ è½½æµ‹è¯•
            setTimeout(() => {
                const endTime = performance.now();
                const loadTime = endTime - startTime;

                recordUITestResult('performance-results',
                    'é¡µé¢åŠ è½½é€Ÿåº¦',
                    loadTime < 3000,
                    `åŠ è½½æ—¶é—´ï¼š${Math.round(loadTime)}ms | æ ‡å‡†ï¼š<3000ms`);
            }, 100);

            // CSSå’ŒJSèµ„æºå¤§å°è¯„ä¼°
            const resourceTests = [
                { type: 'HTML', size: '150KB', acceptable: true },
                { type: 'CSS', size: 'å†…è”CSS', acceptable: true },
                { type: 'JavaScript', size: 'å†…è”JS', acceptable: true },
                { type: 'å¤–éƒ¨ä¾èµ–', size: '0KB', acceptable: true }
            ];

            resourceTests.forEach(resource => {
                recordUITestResult('performance-results',
                    `èµ„æºä¼˜åŒ– - ${resource.type}`,
                    resource.acceptable,
                    `å¤§å°ï¼š${resource.size} | çŠ¶æ€ï¼š${resource.acceptable ? 'ä¼˜åŒ–è‰¯å¥½' : 'éœ€è¦ä¼˜åŒ–'}`);
            });
        }

        function testRenderingPerformance() {
            const renderingTests = [
                { name: 'CSSåŠ¨ç”»æ€§èƒ½', test: () => CSS.supports('will-change', 'transform') },
                { name: 'é‡æ’é‡ç»˜ä¼˜åŒ–', test: () => CSS.supports('contain', 'layout') },
                { name: 'GPUåŠ é€Ÿåˆ©ç”¨', test: () => CSS.supports('transform', 'translateZ(0)') }
            ];

            renderingTests.forEach(test => {
                const passed = test.test();
                recordUITestResult('performance-results',
                    test.name,
                    passed,
                    `ä¼˜åŒ–çŠ¶æ€ï¼š${passed ? 'å·²ä¼˜åŒ–' : 'å¯æ”¹è¿›'}`);
            });
        }

        function testMemoryUsage() {
            if (performance.memory) {
                const memory = performance.memory;
                const usedMB = Math.round(memory.usedJSHeapSize / 1024 / 1024);
                const totalMB = Math.round(memory.totalJSHeapSize / 1024 / 1024);
                const limitMB = Math.round(memory.jsHeapSizeLimit / 1024 / 1024);

                const memoryEfficient = usedMB < 50; // 50MBä»¥ä¸‹è®¤ä¸ºè‰¯å¥½

                recordUITestResult('performance-results',
                    'JavaScriptå†…å­˜ä½¿ç”¨',
                    memoryEfficient,
                    `ä½¿ç”¨ï¼š${usedMB}MB / æ€»è®¡ï¼š${totalMB}MB / é™åˆ¶ï¼š${limitMB}MB`);
            } else {
                recordUIWarning('performance-results',
                    'JavaScriptå†…å­˜ä½¿ç”¨',
                    'å½“å‰æµè§ˆå™¨ä¸æ”¯æŒmemory APIæ£€æµ‹');
            }
        }

        // æ‰§è¡Œæ‰€æœ‰UIæµ‹è¯•
        function runAllUITests() {
            clearResults();
            uiTestStats = { total: 0, passed: 0, failed: 0, warnings: 0 };

            const startTime = performance.now();

            // æŒ‰é¡ºåºæ‰§è¡Œæµ‹è¯•
            runResponsiveTests();
            runInteractionTests();
            runAccessibilityTests();
            runVisualTests();
            runDeviceTests();
            runPerformanceTests();

            const endTime = performance.now();
            const totalTime = Math.round(endTime - startTime);

            // ç”ŸæˆUI/UXç»¼åˆè¯„åˆ†
            generateUIUXSummary(totalTime);
        }

        // ç”ŸæˆUI/UXç»¼åˆè¯„åˆ†
        function generateUIUXSummary(totalTime) {
            const passRate = Math.round((uiTestStats.passed / uiTestStats.total) * 100);
            const uxGrade = getUIUXGrade(passRate);

            const summaryHtml = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 20px;">
                    <div style="text-align: center; padding: 20px; background: var(--card-bg); border-radius: 8px; border: 1px solid var(--border-color);">
                        <h3 style="color: var(--primary-color);">æµ‹è¯•è¦†ç›–</h3>
                        <div style="font-size: 2rem; font-weight: bold; margin: 10px 0;">${uiTestStats.total}</div>
                        <div style="color: var(--text-secondary);">é¡¹æµ‹è¯•</div>
                    </div>
                    <div style="text-align: center; padding: 20px; background: var(--card-bg); border-radius: 8px; border: 1px solid var(--border-color);">
                        <h3 style="color: var(--success-color);">é€šè¿‡ç‡</h3>
                        <div style="font-size: 2rem; font-weight: bold; margin: 10px 0; color: ${uxGrade.color};">${passRate}%</div>
                        <div style="color: var(--text-secondary);">${uiTestStats.passed}/${uiTestStats.total} é€šè¿‡</div>
                    </div>
                    <div style="text-align: center; padding: 20px; background: var(--card-bg); border-radius: 8px; border: 1px solid var(--border-color);">
                        <h3 style="color: var(--primary-color);">UXè¯„çº§</h3>
                        <div style="font-size: 2rem; font-weight: bold; margin: 10px 0; color: ${uxGrade.color};">${uxGrade.level}</div>
                        <div style="color: var(--text-secondary);">${uxGrade.icon}</div>
                    </div>
                    <div style="text-align: center; padding: 20px; background: var(--card-bg); border-radius: 8px; border: 1px solid var(--border-color);">
                        <h3 style="color: var(--primary-color);">æµ‹è¯•æ—¶é—´</h3>
                        <div style="font-size: 2rem; font-weight: bold; margin: 10px 0;">${totalTime}ms</div>
                        <div style="color: var(--text-secondary);">æ‰§è¡Œæ—¶é—´</div>
                    </div>
                </div>

                <div style="padding: 20px; background: rgba(212, 175, 55, 0.1); border-radius: 8px; border-left: 4px solid var(--primary-color);">
                    <h3 style="color: var(--primary-color); margin-bottom: 15px;">UI/UX æ”¹è¿›å»ºè®®</h3>
                    <div style="line-height: 1.8;">
                        ${uxGrade.suggestions.map(suggestion => `â€¢ ${suggestion}`).join('<br>')}
                    </div>
                </div>

                <div style="margin-top: 20px; padding: 15px; background: var(--bg-color); border-radius: 8px; font-size: 0.9rem; color: var(--text-secondary);">
                    <strong>æµ‹è¯•è¯´æ˜ï¼š</strong>æ­¤UI/UXæµ‹è¯•æ¶µç›–äº†å“åº”å¼è®¾è®¡ã€ç”¨æˆ·äº¤äº’ã€æ— éšœç¢è®¿é—®ã€è§†è§‰è®¾è®¡ã€è®¾å¤‡å…¼å®¹æ€§å’Œæ€§èƒ½ä½“éªŒç­‰å…­ä¸ªç»´åº¦ï¼Œä¸ºç³»ç»Ÿçš„ç”¨æˆ·ä½“éªŒä¼˜åŒ–æä¾›æ•°æ®æ”¯æŒã€‚
                </div>
            `;

            document.getElementById('ux-summary').innerHTML = summaryHtml;
        }

        // UI/UXè¯„çº§ç³»ç»Ÿ
        function getUIUXGrade(passRate) {
            if (passRate >= 95) {
                return {
                    level: 'å“è¶Š',
                    color: '#228B22',
                    icon: 'ğŸ†',
                    suggestions: [
                        'UI/UXè®¾è®¡å·²è¾¾åˆ°ä¸šç•Œé¢†å…ˆæ°´å¹³',
                        'å¯ä»¥è€ƒè™‘ç”³è¯·æ— éšœç¢è®¤è¯',
                        'ç»§ç»­ä¿æŒç”¨æˆ·ä½“éªŒçš„æŒç»­ä¼˜åŒ–'
                    ]
                };
            } else if (passRate >= 85) {
                return {
                    level: 'ä¼˜ç§€',
                    color: '#D4AF37',
                    icon: 'ğŸŒŸ',
                    suggestions: [
                        'ç”¨æˆ·ä½“éªŒæ•´ä½“ä¼˜ç§€ï¼Œç»†èŠ‚è¿˜æœ‰æå‡ç©ºé—´',
                        'å»ºè®®è¿›è¡Œç”¨æˆ·æµ‹è¯•éªŒè¯è®¾è®¡å†³ç­–',
                        'å¯ä»¥è€ƒè™‘å¢åŠ æ›´å¤šäº¤äº’ç»†èŠ‚'
                    ]
                };
            } else if (passRate >= 70) {
                return {
                    level: 'è‰¯å¥½',
                    color: '#FF8C00',
                    icon: 'ğŸ‘',
                    suggestions: [
                        'åŸºç¡€ä½“éªŒè‰¯å¥½ï¼Œéœ€è¦é‡ç‚¹ä¼˜åŒ–å¤±è´¥é¡¹',
                        'å»ºè®®å®Œå–„æ— éšœç¢è®¿é—®ç‰¹æ€§',
                        'ä¼˜åŒ–ç§»åŠ¨ç«¯ç”¨æˆ·ä½“éªŒ'
                    ]
                };
            } else if (passRate >= 50) {
                return {
                    level: 'å¾…æ”¹è¿›',
                    color: '#FF6B6B',
                    icon: 'âš ï¸',
                    suggestions: [
                        'ç”¨æˆ·ä½“éªŒå­˜åœ¨æ˜æ˜¾é—®é¢˜ï¼Œéœ€è¦å…¨é¢ä¼˜åŒ–',
                        'ä¼˜å…ˆè§£å†³å“åº”å¼è®¾è®¡å’Œäº¤äº’é—®é¢˜',
                        'å»ºè®®é‡æ–°å®¡è§†è®¾è®¡è§„èŒƒ'
                    ]
                };
            } else {
                return {
                    level: 'éœ€é‡æ„',
                    color: '#DC143C',
                    icon: 'ğŸš¨',
                    suggestions: [
                        'UI/UXéœ€è¦å¤§å¹…åº¦é‡æ„å’Œä¼˜åŒ–',
                        'å»ºè®®å¼•å…¥ä¸“ä¸šUXè®¾è®¡å¸ˆ',
                        'éœ€è¦è¿›è¡Œå…¨é¢çš„ç”¨æˆ·ç ”ç©¶'
                    ]
                };
            }
        }

        // æ¸…é™¤æµ‹è¯•ç»“æœ
        function clearResults() {
            const resultContainers = [
                'responsive-results', 'interaction-results', 'accessibility-results',
                'visual-results', 'device-results', 'performance-results', 'ux-summary'
            ];

            resultContainers.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.innerHTML = '';
            });

            uiTestStats = { total: 0, passed: 0, failed: 0, warnings: 0 };
        }

        // é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨è¿è¡ŒåŸºç¡€æµ‹è¯•
        window.addEventListener('load', () => {
            setTimeout(() => {
                recordUITestResult('responsive-results', 'UIæµ‹è¯•å¥—ä»¶åˆå§‹åŒ–', true,
                    'UI/UXæµ‹è¯•ç¯å¢ƒå‡†å¤‡å®Œæˆï¼Œç‚¹å‡»ä¸Šæ–¹æŒ‰é’®å¼€å§‹æµ‹è¯•');
            }, 500);
        });
    </script>
</body>
</html>