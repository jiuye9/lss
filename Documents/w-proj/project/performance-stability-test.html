<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…­çˆ»æ’ç›˜ç³»ç»Ÿ - æ€§èƒ½ä¸ç¨³å®šæ€§æµ‹è¯•</title>
    <style>
        :root {
            --primary-color: #D4AF37;
            --secondary-color: #B8860B;
            --bg-color: #1A1A1A;
            --card-bg: #2F2F2F;
            --text-color: #F5F5DC;
            --success-color: #228B22;
            --error-color: #DC143C;
            --warning-color: #FF8C00;
            --border-color: #4A4A4A;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background: var(--bg-color);
            min-height: 100vh;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 30px;
            padding: 30px;
            background: var(--card-bg);
            border-radius: 12px;
            border: 2px solid var(--primary-color);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .test-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .test-section {
            background: var(--card-bg);
            padding: 20px;
            margin: 20px 0;
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .test-section h2 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 1.5rem;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 8px;
        }

        .test-result {
            margin: 10px 0;
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid;
        }

        .test-pass {
            background: rgba(34, 139, 34, 0.1);
            border-left-color: var(--success-color);
            color: var(--success-color);
        }

        .test-fail {
            background: rgba(220, 20, 60, 0.1);
            border-left-color: var(--error-color);
            color: var(--error-color);
        }

        .test-warning {
            background: rgba(255, 140, 0, 0.1);
            border-left-color: var(--warning-color);
            color: var(--warning-color);
        }

        .btn {
            background: var(--primary-color);
            color: var(--bg-color);
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            margin: 5px;
            transition: background 0.3s;
        }

        .btn:hover {
            background: var(--secondary-color);
        }

        .test-controls {
            text-align: center;
            margin-bottom: 30px;
        }

        .test-detail {
            font-size: 0.9rem;
            margin-top: 8px;
            opacity: 0.9;
        }

        .performance-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .metric-card {
            background: var(--bg-color);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            margin: 10px 0;
        }

        .metric-excellent { color: var(--success-color); }
        .metric-good { color: var(--primary-color); }
        .metric-fair { color: var(--warning-color); }
        .metric-poor { color: var(--error-color); }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-color);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--success-color);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .chart-container {
            margin: 15px 0;
            padding: 15px;
            background: var(--bg-color);
            border-radius: 8px;
        }

        .chart-bar {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }

        .chart-label {
            width: 120px;
            font-size: 0.9rem;
        }

        .chart-value {
            flex: 1;
            margin: 0 10px;
        }

        .chart-number {
            width: 60px;
            text-align: right;
            font-weight: bold;
        }

        .stress-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-running { background: var(--warning-color); }
        .status-complete { background: var(--success-color); }
        .status-error { background: var(--error-color); }

        @media (max-width: 768px) {
            .performance-metrics {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>å…­çˆ»æ’ç›˜ç³»ç»Ÿæ€§èƒ½ä¸ç¨³å®šæ€§æµ‹è¯•</h1>
        <p>å…¨é¢è¯„ä¼°ç³»ç»Ÿæ€§èƒ½è¡¨ç°ã€å†…å­˜ä½¿ç”¨å’Œç¨³å®šæ€§</p>
        <div id="test-timestamp"></div>
    </div>

    <div class="test-controls">
        <button class="btn" onclick="runAllPerformanceTests()">æ‰§è¡Œå…¨éƒ¨æ€§èƒ½æµ‹è¯•</button>
        <button class="btn" onclick="runLoadTests()">è´Ÿè½½æµ‹è¯•</button>
        <button class="btn" onclick="runStressTests()">å‹åŠ›æµ‹è¯•</button>
        <button class="btn" onclick="runMemoryTests()">å†…å­˜æµ‹è¯•</button>
        <button class="btn" onclick="runStabilityTests()">ç¨³å®šæ€§æµ‹è¯•</button>
        <button class="btn" onclick="clearResults()">æ¸…é™¤ç»“æœ</button>
    </div>

    <div class="test-container">
        <div class="test-section">
            <h2>ğŸ“Š æ€§èƒ½æŒ‡æ ‡æ¦‚è§ˆ</h2>
            <div id="performance-overview" class="performance-metrics"></div>
        </div>

        <div class="test-section">
            <h2>âš¡ ç®—æ³•æ‰§è¡Œæ€§èƒ½</h2>
            <div id="algorithm-performance-results"></div>
        </div>

        <div class="test-section">
            <h2>ğŸ’¾ å†…å­˜ä½¿ç”¨åˆ†æ</h2>
            <div id="memory-analysis-results"></div>
        </div>

        <div class="test-section">
            <h2>ğŸ”„ è´Ÿè½½æµ‹è¯•ç»“æœ</h2>
            <div id="load-test-results"></div>
        </div>

        <div class="test-section">
            <h2>ğŸ”¥ å‹åŠ›æµ‹è¯•ç»“æœ</h2>
            <div id="stress-test-results"></div>
        </div>

        <div class="test-section">
            <h2>ğŸ›¡ï¸ ç¨³å®šæ€§æµ‹è¯•</h2>
            <div id="stability-test-results"></div>
        </div>

        <div class="test-section">
            <h2>ğŸ“ˆ æ€§èƒ½åŸºå‡†æµ‹è¯•</h2>
            <div id="benchmark-results"></div>
        </div>

        <div class="test-section">
            <h2>ğŸ“‹ ç»¼åˆæ€§èƒ½è¯„ä¼°</h2>
            <div id="performance-summary"></div>
        </div>
    </div>

    <script>
        // å…¨å±€æ€§èƒ½æµ‹è¯•ç»Ÿè®¡
        let performanceStats = {
            algorithmTests: [],
            memoryUsage: [],
            loadTests: [],
            stressTests: [],
            stabilityTests: [],
            benchmarks: []
        };

        // åˆå§‹åŒ–æ—¶é—´æˆ³
        document.getElementById('test-timestamp').textContent =
            `æµ‹è¯•æ—¶é—´ï¼š${new Date().toLocaleString('zh-CN')}`;

        // æ€§èƒ½æµ‹è¯•ç»“æœè®°å½•å‡½æ•°
        function recordPerformanceResult(elementId, testName, duration, status, details = '', metrics = {}) {
            const statusClass = status === 'pass' ? 'test-pass' :
                               status === 'warning' ? 'test-warning' : 'test-fail';
            const statusIcon = status === 'pass' ? 'âœ…' :
                              status === 'warning' ? 'âš ï¸' : 'âŒ';

            const metricsInfo = Object.keys(metrics).length > 0 ?
                `<div class="test-detail"><strong>æŒ‡æ ‡ï¼š</strong>${Object.entries(metrics).map(([k,v]) => `${k}: ${v}`).join(' | ')}</div>` : '';

            const resultHtml = `
                <div class="test-result ${statusClass}">
                    <strong>${statusIcon} ${testName}</strong>
                    <span style="float: right; font-weight: bold;">${duration}ms</span>
                    <div class="test-detail">${details}</div>
                    ${metricsInfo}
                </div>
            `;

            document.getElementById(elementId).innerHTML += resultHtml;
        }

        // æ¨¡æ‹Ÿå…­çˆ»æ’ç›˜æ ¸å¿ƒç®—æ³•
        function simulateTimeToHexagram(iterations = 1) {
            const start = performance.now();

            for (let i = 0; i < iterations; i++) {
                // æ¨¡æ‹Ÿæ—¶é—´èµ·å¦ç®—æ³•
                const now = new Date();
                const year = now.getFullYear();
                const month = now.getMonth() + 1;
                const day = now.getDate();
                const hour = now.getHours();

                // ä¿®å¤åçš„åŠ¨çˆ»è®¡ç®—
                const changingLine = ((year + month + day + hour - 1) % 6) + 1;

                // æ¨¡æ‹Ÿå¦è±¡ç”Ÿæˆ
                const upperTrigram = (year + month) % 8;
                const lowerTrigram = (day + hour) % 8;

                // æ¨¡æ‹Ÿå…­äº²è®¡ç®—
                const sixRelations = calculateSixRelations(year, month, day);

                // æ¨¡æ‹Ÿå…­ç¥æ’å¸ƒ
                const sixSpirits = arrangeSixSpirits(day % 6);
            }

            const end = performance.now();
            return end - start;
        }

        function calculateSixRelations(year, month, day) {
            // æ¨¡æ‹Ÿå…­äº²è®¡ç®—é€»è¾‘
            const relations = ['å…„å¼Ÿ', 'å­å­™', 'å¦»è´¢', 'å®˜é¬¼', 'çˆ¶æ¯'];
            const result = [];
            for (let i = 0; i < 6; i++) {
                result.push(relations[(year + month + day + i) % relations.length]);
            }
            return result;
        }

        function arrangeSixSpirits(startIndex) {
            const spirits = ['é’é¾™', 'æœ±é›€', 'å‹¾é™ˆ', 'è…¾è›‡', 'ç™½è™', 'ç„æ­¦'];
            const result = [];
            for (let i = 0; i < 6; i++) {
                result.push(spirits[(startIndex + i) % spirits.length]);
            }
            return result;
        }

        // ç®—æ³•æ‰§è¡Œæ€§èƒ½æµ‹è¯•
        function runAlgorithmPerformanceTests() {
            const tests = [
                { name: 'å•æ¬¡æ—¶é—´èµ·å¦', iterations: 1, threshold: 10 },
                { name: 'æ‰¹é‡æ—¶é—´èµ·å¦(100æ¬¡)', iterations: 100, threshold: 500 },
                { name: 'æ‰¹é‡æ—¶é—´èµ·å¦(1000æ¬¡)', iterations: 1000, threshold: 3000 },
                { name: 'å…­äº²è®¡ç®—æ€§èƒ½', iterations: 500, threshold: 200 },
                { name: 'å…­ç¥æ’å¸ƒæ€§èƒ½', iterations: 1000, threshold: 100 }
            ];

            tests.forEach(test => {
                const startMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                const duration = simulateTimeToHexagram(test.iterations);
                const endMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                const memoryDiff = endMemory - startMemory;

                const avgDuration = duration / test.iterations;
                const passed = duration < test.threshold;

                performanceStats.algorithmTests.push({
                    name: test.name,
                    duration,
                    avgDuration,
                    iterations: test.iterations,
                    memoryDiff,
                    passed
                });

                recordPerformanceResult('algorithm-performance-results',
                    test.name,
                    Math.round(duration * 100) / 100,
                    passed ? 'pass' : 'warning',
                    `å¹³å‡è€—æ—¶: ${Math.round(avgDuration * 100) / 100}ms/æ¬¡ | å†…å­˜å˜åŒ–: ${Math.round(memoryDiff/1024)}KB | é˜ˆå€¼: ${test.threshold}ms`,
                    {
                        'è¿­ä»£æ¬¡æ•°': test.iterations,
                        'æ€»è€—æ—¶': `${Math.round(duration)}ms`,
                        'å¹³å‡è€—æ—¶': `${Math.round(avgDuration * 100) / 100}ms`
                    });
            });

            // ç®—æ³•å¤æ‚åº¦åˆ†æ
            analyzeAlgorithmComplexity();
        }

        function analyzeAlgorithmComplexity() {
            const testSizes = [10, 50, 100, 500, 1000, 5000];
            const complexityData = [];

            testSizes.forEach(size => {
                const duration = simulateTimeToHexagram(size);
                const avgTime = duration / size;
                complexityData.push({ size, duration, avgTime });
            });

            // åˆ†ææ—¶é—´å¤æ‚åº¦è¶‹åŠ¿
            const isLinear = analyzeComplexityTrend(complexityData);

            recordPerformanceResult('algorithm-performance-results',
                'ç®—æ³•å¤æ‚åº¦åˆ†æ',
                0,
                isLinear ? 'pass' : 'warning',
                `æ—¶é—´å¤æ‚åº¦: ${isLinear ? 'O(n) çº¿æ€§å¢é•¿' : 'éçº¿æ€§å¢é•¿ï¼Œéœ€è¦ä¼˜åŒ–'} | æœ€å¤§æµ‹è¯•è§„æ¨¡: ${Math.max(...testSizes)}æ¬¡`,
                {
                    'å¤æ‚åº¦ç‰¹å¾': isLinear ? 'çº¿æ€§' : 'éçº¿æ€§',
                    'å¯æ‰©å±•æ€§': isLinear ? 'è‰¯å¥½' : 'éœ€ä¼˜åŒ–'
                });
        }

        function analyzeComplexityTrend(data) {
            // ç®€å•çš„çº¿æ€§åº¦æ£€æµ‹
            if (data.length < 3) return true;

            const avgTimeVariation = data.map(d => d.avgTime);
            const maxVariation = Math.max(...avgTimeVariation);
            const minVariation = Math.min(...avgTimeVariation);

            // å¦‚æœå¹³å‡æ—¶é—´å˜åŒ–ä¸è¶…è¿‡2å€ï¼Œè®¤ä¸ºæ˜¯çº¿æ€§çš„
            return (maxVariation / minVariation) < 2;
        }

        // å†…å­˜ä½¿ç”¨åˆ†æ
        function runMemoryTests() {
            if (!performance.memory) {
                recordPerformanceResult('memory-analysis-results',
                    'å†…å­˜APIæ”¯æŒæ£€æµ‹',
                    0,
                    'warning',
                    'å½“å‰æµè§ˆå™¨ä¸æ”¯æŒmemory APIï¼Œæ— æ³•è¿›è¡Œç²¾ç¡®çš„å†…å­˜åˆ†æ');
                return;
            }

            const initialMemory = performance.memory.usedJSHeapSize;

            // å†…å­˜å‹åŠ›æµ‹è¯•
            const memoryStressTest = () => {
                const largeArrays = [];
                for (let i = 0; i < 100; i++) {
                    // åˆ›å»ºå¤§é‡æ•°æ®æ¨¡æ‹Ÿå†…å­˜ä½¿ç”¨
                    largeArrays.push(new Array(10000).fill(0).map(() => ({
                        å¦å: 'æ°´å¤©éœ€',
                        å…­çˆ»: new Array(6).fill(0).map(() => ({
                            é˜´é˜³: Math.random() > 0.5 ? 'é˜´' : 'é˜³',
                            å…­äº²: ['å…„å¼Ÿ', 'å­å­™', 'å¦»è´¢', 'å®˜é¬¼', 'çˆ¶æ¯'][Math.floor(Math.random() * 5)],
                            å…­ç¥: ['é’é¾™', 'æœ±é›€', 'å‹¾é™ˆ', 'è…¾è›‡', 'ç™½è™', 'ç„æ­¦'][Math.floor(Math.random() * 6)]
                        }))
                    })));
                }
                return largeArrays.length;
            };

            const startTime = performance.now();
            const arrayCount = memoryStressTest();
            const endTime = performance.now();

            const finalMemory = performance.memory.usedJSHeapSize;
            const memoryIncrease = finalMemory - initialMemory;
            const memoryMB = Math.round(memoryIncrease / 1024 / 1024 * 100) / 100;

            performanceStats.memoryUsage.push({
                test: 'å†…å­˜å‹åŠ›æµ‹è¯•',
                initialMemory,
                finalMemory,
                memoryIncrease,
                duration: endTime - startTime,
                arrayCount
            });

            recordPerformanceResult('memory-analysis-results',
                'å†…å­˜å‹åŠ›æµ‹è¯•',
                Math.round(endTime - startTime),
                memoryMB < 100 ? 'pass' : memoryMB < 200 ? 'warning' : 'fail',
                `å†…å­˜å¢é•¿: ${memoryMB}MB | åˆ›å»ºå¯¹è±¡: ${arrayCount}ä¸ªæ•°ç»„ | å†…å­˜æ•ˆç‡: ${memoryMB < 100 ? 'ä¼˜ç§€' : memoryMB < 200 ? 'è‰¯å¥½' : 'éœ€ä¼˜åŒ–'}`,
                {
                    'å†…å­˜å¢é•¿': `${memoryMB}MB`,
                    'å¯¹è±¡æ•°é‡': arrayCount,
                    'å†…å­˜æ•ˆç‡': memoryMB < 50 ? 'ä¼˜ç§€' : memoryMB < 100 ? 'è‰¯å¥½' : 'ä¸€èˆ¬'
                });

            // åƒåœ¾å›æ”¶æµ‹è¯•
            setTimeout(() => {
                runGarbageCollectionTest(initialMemory);
            }, 1000);

            // å†…å­˜æ³„æ¼æ£€æµ‹
            detectMemoryLeaks();
        }

        function runGarbageCollectionTest(baselineMemory) {
            if (window.gc) {
                window.gc(); // å¼ºåˆ¶åƒåœ¾å›æ”¶ï¼ˆä»…åœ¨ç‰¹å®šæµè§ˆå™¨è®¾ç½®ä¸‹æœ‰æ•ˆï¼‰
            }

            setTimeout(() => {
                const currentMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                const memoryAfterGC = currentMemory - baselineMemory;
                const memoryMB = Math.round(memoryAfterGC / 1024 / 1024 * 100) / 100;

                recordPerformanceResult('memory-analysis-results',
                    'åƒåœ¾å›æ”¶æ•ˆæœæµ‹è¯•',
                    0,
                    memoryMB < 10 ? 'pass' : 'warning',
                    `GCåå†…å­˜æ®‹ç•™: ${memoryMB}MB | å›æ”¶æ•ˆæœ: ${memoryMB < 5 ? 'ä¼˜ç§€' : memoryMB < 10 ? 'è‰¯å¥½' : 'ä¸€èˆ¬'}`,
                    {
                        'GCåå†…å­˜': `${memoryMB}MB`,
                        'å›æ”¶ç‡': memoryMB < 5 ? '>95%' : memoryMB < 10 ? '>90%' : '<90%'
                    });
            }, 2000);
        }

        function detectMemoryLeaks() {
            const measurements = [];
            let measurementCount = 0;

            const measureMemory = () => {
                if (performance.memory && measurementCount < 10) {
                    measurements.push(performance.memory.usedJSHeapSize);
                    measurementCount++;

                    // æ¨¡æ‹Ÿä¸€äº›æ“ä½œ
                    simulateTimeToHexagram(10);

                    setTimeout(measureMemory, 200);
                } else if (measurements.length > 3) {
                    analyzePotentialLeaks(measurements);
                }
            };

            measureMemory();
        }

        function analyzePotentialLeaks(measurements) {
            const trend = calculateMemoryTrend(measurements);
            const hasLeak = trend > 1024 * 1024; // è¶…è¿‡1MBå¢é•¿è¶‹åŠ¿è®¤ä¸ºå¯èƒ½æœ‰æ³„æ¼

            recordPerformanceResult('memory-analysis-results',
                'å†…å­˜æ³„æ¼æ£€æµ‹',
                0,
                hasLeak ? 'warning' : 'pass',
                `å†…å­˜å¢é•¿è¶‹åŠ¿: ${Math.round(trend/1024)}KB | æ³„æ¼é£é™©: ${hasLeak ? 'ä¸­ç­‰' : 'ä½'} | å»ºè®®: ${hasLeak ? 'éœ€è¦ä»£ç å®¡æŸ¥' : 'å†…å­˜ç®¡ç†è‰¯å¥½'}`,
                {
                    'å†…å­˜è¶‹åŠ¿': `${Math.round(trend/1024)}KB`,
                    'æ³„æ¼é£é™©': hasLeak ? 'ä¸­ç­‰' : 'ä½',
                    'ç›‘æµ‹æ¬¡æ•°': measurements.length
                });
        }

        function calculateMemoryTrend(measurements) {
            if (measurements.length < 2) return 0;
            const first = measurements[0];
            const last = measurements[measurements.length - 1];
            return last - first;
        }

        // è´Ÿè½½æµ‹è¯•
        function runLoadTests() {
            const loadScenarios = [
                { name: 'è½»è´Ÿè½½æµ‹è¯•', concurrent: 5, duration: 1000 },
                { name: 'ä¸­ç­‰è´Ÿè½½æµ‹è¯•', concurrent: 20, duration: 2000 },
                { name: 'é«˜è´Ÿè½½æµ‹è¯•', concurrent: 50, duration: 3000 },
                { name: 'æé™è´Ÿè½½æµ‹è¯•', concurrent: 100, duration: 5000 }
            ];

            loadScenarios.forEach((scenario, index) => {
                setTimeout(() => {
                    executeLoadScenario(scenario);
                }, index * 1000);
            });
        }

        function executeLoadScenario(scenario) {
            const startTime = performance.now();
            const promises = [];

            for (let i = 0; i < scenario.concurrent; i++) {
                promises.push(new Promise(resolve => {
                    const taskStart = performance.now();
                    simulateTimeToHexagram(Math.floor(Math.random() * 10) + 1);
                    const taskEnd = performance.now();
                    resolve(taskEnd - taskStart);
                }));
            }

            Promise.all(promises).then(durations => {
                const endTime = performance.now();
                const totalDuration = endTime - startTime;
                const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
                const maxDuration = Math.max(...durations);
                const minDuration = Math.min(...durations);

                const throughput = (scenario.concurrent / totalDuration * 1000).toFixed(2);
                const success = totalDuration < scenario.duration;

                performanceStats.loadTests.push({
                    scenario: scenario.name,
                    concurrent: scenario.concurrent,
                    totalDuration,
                    avgDuration,
                    maxDuration,
                    minDuration,
                    throughput,
                    success
                });

                recordPerformanceResult('load-test-results',
                    scenario.name,
                    Math.round(totalDuration),
                    success ? 'pass' : 'warning',
                    `å¹¶å‘æ•°: ${scenario.concurrent} | ååé‡: ${throughput}ops/s | å¹³å‡å“åº”: ${Math.round(avgDuration)}ms | æœ€å¤§å“åº”: ${Math.round(maxDuration)}ms`,
                    {
                        'å¹¶å‘æ•°': scenario.concurrent,
                        'ååé‡': `${throughput}ops/s`,
                        'å“åº”æ—¶é—´': `${Math.round(avgDuration)}ms`
                    });
            });
        }

        // å‹åŠ›æµ‹è¯•
        function runStressTests() {
            const stressScenarios = [
                { name: 'CPUå¯†é›†å‹å‹åŠ›æµ‹è¯•', type: 'cpu', intensity: 'high' },
                { name: 'å†…å­˜å¯†é›†å‹å‹åŠ›æµ‹è¯•', type: 'memory', intensity: 'high' },
                { name: 'ç»¼åˆå‹åŠ›æµ‹è¯•', type: 'combined', intensity: 'extreme' }
            ];

            stressScenarios.forEach((scenario, index) => {
                setTimeout(() => {
                    executeStressScenario(scenario);
                }, index * 2000);
            });
        }

        function executeStressScenario(scenario) {
            const startTime = performance.now();
            let completed = false;

            updateStressIndicator(scenario.name, 'running');

            const stressTest = () => {
                const iterationStart = performance.now();
                let operations = 0;

                while (performance.now() - iterationStart < 100 && !completed) {
                    if (scenario.type === 'cpu' || scenario.type === 'combined') {
                        // CPUå¯†é›†å‹æ“ä½œ
                        simulateTimeToHexagram(5);
                        operations++;
                    }

                    if (scenario.type === 'memory' || scenario.type === 'combined') {
                        // å†…å­˜å¯†é›†å‹æ“ä½œ
                        const tempArray = new Array(1000).fill(0).map(() => Math.random());
                        operations += tempArray.length / 1000;
                    }
                }

                return operations;
            };

            // è¿è¡Œå‹åŠ›æµ‹è¯•30ç§’
            const testDuration = 30000;
            const testInterval = setInterval(() => {
                try {
                    stressTest();
                } catch (error) {
                    clearInterval(testInterval);
                    completed = true;
                    recordStressTestFailure(scenario, error, performance.now() - startTime);
                }
            }, 100);

            setTimeout(() => {
                clearInterval(testInterval);
                completed = true;
                const endTime = performance.now();
                const totalDuration = endTime - startTime;

                recordStressTestSuccess(scenario, totalDuration);
                updateStressIndicator(scenario.name, 'complete');
            }, testDuration);
        }

        function updateStressIndicator(testName, status) {
            // æ›´æ–°å‹åŠ›æµ‹è¯•æŒ‡ç¤ºå™¨
            const indicator = document.querySelector(`[data-stress-test="${testName}"]`);
            if (!indicator) {
                const indicatorHtml = `
                    <div data-stress-test="${testName}" style="margin: 10px 0;">
                        <span class="stress-indicator status-${status}"></span>
                        <span>${testName}</span>
                        <span style="float: right;">${status === 'running' ? 'è¿è¡Œä¸­...' : 'å·²å®Œæˆ'}</span>
                    </div>
                `;
                document.getElementById('stress-test-results').innerHTML += indicatorHtml;
            } else {
                const statusIndicator = indicator.querySelector('.stress-indicator');
                statusIndicator.className = `stress-indicator status-${status}`;
                indicator.querySelector('span:last-child').textContent =
                    status === 'running' ? 'è¿è¡Œä¸­...' : status === 'complete' ? 'å·²å®Œæˆ' : 'é”™è¯¯';
            }
        }

        function recordStressTestSuccess(scenario, duration) {
            performanceStats.stressTests.push({
                scenario: scenario.name,
                type: scenario.type,
                intensity: scenario.intensity,
                duration,
                success: true
            });

            recordPerformanceResult('stress-test-results',
                scenario.name,
                Math.round(duration),
                'pass',
                `å‹åŠ›ç±»å‹: ${scenario.type} | å¼ºåº¦: ${scenario.intensity} | ç³»ç»Ÿç¨³å®šè¿è¡Œ | æ— å´©æºƒæˆ–é”™è¯¯`,
                {
                    'å‹åŠ›ç±»å‹': scenario.type,
                    'æµ‹è¯•å¼ºåº¦': scenario.intensity,
                    'è¿è¡ŒçŠ¶æ€': 'ç¨³å®š'
                });
        }

        function recordStressTestFailure(scenario, error, duration) {
            performanceStats.stressTests.push({
                scenario: scenario.name,
                type: scenario.type,
                intensity: scenario.intensity,
                duration,
                success: false,
                error: error.message
            });

            recordPerformanceResult('stress-test-results',
                scenario.name,
                Math.round(duration),
                'fail',
                `å‹åŠ›æµ‹è¯•å¤±è´¥ | é”™è¯¯: ${error.message} | å»ºè®®: ä¼˜åŒ–ç®—æ³•æ€§èƒ½æˆ–å¢åŠ é”™è¯¯å¤„ç†`,
                {
                    'å¤±è´¥åŸå› ': error.message,
                    'è¿è¡Œæ—¶é•¿': `${Math.round(duration)}ms`,
                    'ç¨³å®šæ€§': 'éœ€æ”¹è¿›'
                });

            updateStressIndicator(scenario.name, 'error');
        }

        // ç¨³å®šæ€§æµ‹è¯•
        function runStabilityTests() {
            const stabilityTests = [
                { name: 'é•¿æ—¶é—´è¿è¡Œæµ‹è¯•', duration: 60000, interval: 1000 },
                { name: 'å¼‚å¸¸è¾“å…¥å¤„ç†æµ‹è¯•', type: 'exception' },
                { name: 'è¾¹ç•Œå€¼æµ‹è¯•', type: 'boundary' },
                { name: 'å¹¶å‘ç¨³å®šæ€§æµ‹è¯•', type: 'concurrent' }
            ];

            stabilityTests.forEach((test, index) => {
                setTimeout(() => {
                    executeStabilityTest(test);
                }, index * 5000);
            });
        }

        function executeStabilityTest(test) {
            if (test.type === 'exception') {
                testExceptionHandling();
            } else if (test.type === 'boundary') {
                testBoundaryValues();
            } else if (test.type === 'concurrent') {
                testConcurrentStability();
            } else {
                testLongRunning(test);
            }
        }

        function testExceptionHandling() {
            const exceptionTests = [
                { input: null, desc: 'ç©ºå€¼è¾“å…¥' },
                { input: undefined, desc: 'æœªå®šä¹‰è¾“å…¥' },
                { input: '', desc: 'ç©ºå­—ç¬¦ä¸²' },
                { input: 'invalid', desc: 'æ— æ•ˆå­—ç¬¦ä¸²' },
                { input: -1, desc: 'è´Ÿæ•°è¾“å…¥' },
                { input: Infinity, desc: 'æ— ç©·å¤§è¾“å…¥' }
            ];

            let passCount = 0;
            exceptionTests.forEach(testCase => {
                try {
                    // æ¨¡æ‹Ÿå¼‚å¸¸è¾“å…¥æµ‹è¯•
                    const result = simulateTimeToHexagram(typeof testCase.input === 'number' ? testCase.input : 1);
                    passCount++;
                } catch (error) {
                    // æœŸæœ›çš„å¼‚å¸¸æƒ…å†µ
                    passCount++;
                }
            });

            recordPerformanceResult('stability-test-results',
                'å¼‚å¸¸è¾“å…¥å¤„ç†æµ‹è¯•',
                0,
                passCount === exceptionTests.length ? 'pass' : 'warning',
                `å¼‚å¸¸å¤„ç†æµ‹è¯•: ${passCount}/${exceptionTests.length}ä¸ªåœºæ™¯é€šè¿‡ | ç³»ç»Ÿç¨³å®šæ€§: ${passCount === exceptionTests.length ? 'ä¼˜ç§€' : 'éœ€æ”¹è¿›'}`,
                {
                    'æµ‹è¯•åœºæ™¯': exceptionTests.length,
                    'é€šè¿‡æ•°é‡': passCount,
                    'ç¨³å®šæ€§': passCount === exceptionTests.length ? 'ä¼˜ç§€' : 'ä¸€èˆ¬'
                });
        }

        function testBoundaryValues() {
            const boundaryTests = [
                { value: 0, desc: 'æœ€å°å€¼' },
                { value: 1, desc: 'æœ€å°æ­£å€¼' },
                { value: 6, desc: 'å…­çˆ»æœ€å¤§å€¼' },
                { value: 2025, desc: 'å¹´ä»½è¾¹ç•Œ' },
                { value: 12, desc: 'æœˆä»½è¾¹ç•Œ' },
                { value: 31, desc: 'æ—¥æœŸè¾¹ç•Œ' },
                { value: 23, desc: 'å°æ—¶è¾¹ç•Œ' }
            ];

            let passCount = 0;
            boundaryTests.forEach(testCase => {
                try {
                    const duration = simulateTimeToHexagram(1);
                    if (duration < 1000) passCount++; // 1ç§’å†…å®Œæˆè®¤ä¸ºæ­£å¸¸
                } catch (error) {
                    // è¾¹ç•Œå€¼æµ‹è¯•å¤±è´¥
                }
            });

            recordPerformanceResult('stability-test-results',
                'è¾¹ç•Œå€¼æµ‹è¯•',
                0,
                passCount >= boundaryTests.length * 0.8 ? 'pass' : 'warning',
                `è¾¹ç•Œå€¼æµ‹è¯•: ${passCount}/${boundaryTests.length}ä¸ªè¾¹ç•Œå€¼æ­£å¸¸å¤„ç† | è¾¹ç•Œå¤„ç†èƒ½åŠ›: ${passCount >= boundaryTests.length * 0.8 ? 'è‰¯å¥½' : 'éœ€æ”¹è¿›'}`,
                {
                    'è¾¹ç•Œæµ‹è¯•': boundaryTests.length,
                    'æ­£å¸¸å¤„ç†': passCount,
                    'å¤„ç†ç‡': `${Math.round(passCount/boundaryTests.length*100)}%`
                });
        }

        function testConcurrentStability() {
            const concurrentPromises = [];
            const concurrentCount = 20;

            for (let i = 0; i < concurrentCount; i++) {
                concurrentPromises.push(new Promise(resolve => {
                    try {
                        const duration = simulateTimeToHexagram(Math.floor(Math.random() * 5) + 1);
                        resolve({ success: true, duration });
                    } catch (error) {
                        resolve({ success: false, error: error.message });
                    }
                }));
            }

            Promise.all(concurrentPromises).then(results => {
                const successCount = results.filter(r => r.success).length;
                const avgDuration = results.filter(r => r.success).reduce((sum, r) => sum + r.duration, 0) / successCount;

                recordPerformanceResult('stability-test-results',
                    'å¹¶å‘ç¨³å®šæ€§æµ‹è¯•',
                    Math.round(avgDuration),
                    successCount === concurrentCount ? 'pass' : 'warning',
                    `å¹¶å‘æ‰§è¡Œ: ${concurrentCount}ä¸ªä»»åŠ¡ | æˆåŠŸ: ${successCount}ä¸ª | å¹³å‡å“åº”: ${Math.round(avgDuration)}ms | å¹¶å‘ç¨³å®šæ€§: ${successCount === concurrentCount ? 'ä¼˜ç§€' : 'éœ€æ”¹è¿›'}`,
                    {
                        'å¹¶å‘ä»»åŠ¡': concurrentCount,
                        'æˆåŠŸæ•°é‡': successCount,
                        'æˆåŠŸç‡': `${Math.round(successCount/concurrentCount*100)}%`
                    });
            });
        }

        function testLongRunning(test) {
            let iterations = 0;
            let errors = 0;
            const startTime = performance.now();

            const interval = setInterval(() => {
                try {
                    simulateTimeToHexagram(1);
                    iterations++;
                } catch (error) {
                    errors++;
                }
            }, test.interval);

            setTimeout(() => {
                clearInterval(interval);
                const endTime = performance.now();
                const totalDuration = endTime - startTime;
                const errorRate = errors / iterations;

                performanceStats.stabilityTests.push({
                    test: test.name,
                    duration: totalDuration,
                    iterations,
                    errors,
                    errorRate
                });

                recordPerformanceResult('stability-test-results',
                    test.name,
                    Math.round(totalDuration),
                    errorRate < 0.01 ? 'pass' : 'warning',
                    `è¿è¡Œæ—¶é•¿: ${Math.round(totalDuration/1000)}ç§’ | æ‰§è¡Œæ¬¡æ•°: ${iterations} | é”™è¯¯æ•°: ${errors} | é”™è¯¯ç‡: ${(errorRate*100).toFixed(3)}% | é•¿æœŸç¨³å®šæ€§: ${errorRate < 0.01 ? 'ä¼˜ç§€' : 'éœ€å…³æ³¨'}`,
                    {
                        'æ‰§è¡Œæ¬¡æ•°': iterations,
                        'é”™è¯¯æ•°é‡': errors,
                        'é”™è¯¯ç‡': `${(errorRate*100).toFixed(3)}%`
                    });
            }, test.duration);
        }

        // æ€§èƒ½åŸºå‡†æµ‹è¯•
        function runBenchmarkTests() {
            const benchmarks = [
                { name: 'åŸºå‡†æ’ç›˜é€Ÿåº¦', target: 10, unit: 'ms' },
                { name: 'åŸºå‡†å†…å­˜ä½¿ç”¨', target: 50, unit: 'MB' },
                { name: 'åŸºå‡†ååé‡', target: 100, unit: 'ops/s' },
                { name: 'åŸºå‡†å“åº”æ—¶é—´', target: 100, unit: 'ms' }
            ];

            benchmarks.forEach(benchmark => {
                const result = executeBenchmark(benchmark);
                performanceStats.benchmarks.push(result);

                recordPerformanceResult('benchmark-results',
                    benchmark.name,
                    result.value,
                    result.passed ? 'pass' : 'warning',
                    `åŸºå‡†å€¼: ${benchmark.target}${benchmark.unit} | å®æµ‹å€¼: ${result.value}${benchmark.unit} | æ€§èƒ½è¯„çº§: ${result.grade}`,
                    {
                        'åŸºå‡†å€¼': `${benchmark.target}${benchmark.unit}`,
                        'å®æµ‹å€¼': `${result.value}${benchmark.unit}`,
                        'æ€§èƒ½ç­‰çº§': result.grade
                    });
            });
        }

        function executeBenchmark(benchmark) {
            let value, passed, grade;

            switch (benchmark.name) {
                case 'åŸºå‡†æ’ç›˜é€Ÿåº¦':
                    value = Math.round(simulateTimeToHexagram(1) * 100) / 100;
                    passed = value < benchmark.target;
                    grade = value < benchmark.target * 0.5 ? 'ä¼˜ç§€' :
                           value < benchmark.target ? 'è‰¯å¥½' : 'ä¸€èˆ¬';
                    break;

                case 'åŸºå‡†å†…å­˜ä½¿ç”¨':
                    // æ¨¡æ‹Ÿå†…å­˜ä½¿ç”¨æµ‹è¯•
                    const memBefore = performance.memory ? performance.memory.usedJSHeapSize : 0;
                    simulateTimeToHexagram(100);
                    const memAfter = performance.memory ? performance.memory.usedJSHeapSize : 0;
                    value = Math.round((memAfter - memBefore) / 1024 / 1024 * 100) / 100;
                    passed = value < benchmark.target;
                    grade = value < benchmark.target * 0.5 ? 'ä¼˜ç§€' :
                           value < benchmark.target ? 'è‰¯å¥½' : 'ä¸€èˆ¬';
                    break;

                case 'åŸºå‡†ååé‡':
                    const start = performance.now();
                    const iterations = 100;
                    simulateTimeToHexagram(iterations);
                    const duration = performance.now() - start;
                    value = Math.round((iterations / duration * 1000) * 100) / 100;
                    passed = value > benchmark.target;
                    grade = value > benchmark.target * 2 ? 'ä¼˜ç§€' :
                           value > benchmark.target ? 'è‰¯å¥½' : 'ä¸€èˆ¬';
                    break;

                case 'åŸºå‡†å“åº”æ—¶é—´':
                    value = Math.round(simulateTimeToHexagram(1) * 100) / 100;
                    passed = value < benchmark.target;
                    grade = value < benchmark.target * 0.3 ? 'ä¼˜ç§€' :
                           value < benchmark.target * 0.7 ? 'è‰¯å¥½' : 'ä¸€èˆ¬';
                    break;
            }

            return { name: benchmark.name, value, passed, grade };
        }

        // æ‰§è¡Œå…¨éƒ¨æ€§èƒ½æµ‹è¯•
        function runAllPerformanceTests() {
            clearResults();
            performanceStats = {
                algorithmTests: [],
                memoryUsage: [],
                loadTests: [],
                stressTests: [],
                stabilityTests: [],
                benchmarks: []
            };

            const startTime = performance.now();

            // æŒ‰é¡ºåºæ‰§è¡Œæµ‹è¯•
            runAlgorithmPerformanceTests();

            setTimeout(() => runMemoryTests(), 1000);
            setTimeout(() => runLoadTests(), 3000);
            setTimeout(() => runStressTests(), 8000);
            setTimeout(() => runStabilityTests(), 15000);
            setTimeout(() => runBenchmarkTests(), 25000);

            // 30ç§’åç”Ÿæˆç»¼åˆæŠ¥å‘Š
            setTimeout(() => {
                const endTime = performance.now();
                const totalTestTime = Math.round(endTime - startTime);
                generatePerformanceSummary(totalTestTime);
                updatePerformanceOverview();
            }, 30000);
        }

        // æ›´æ–°æ€§èƒ½æ¦‚è§ˆ
        function updatePerformanceOverview() {
            const overviewHtml = `
                <div class="metric-card">
                    <h4>ç®—æ³•æ€§èƒ½</h4>
                    <div class="metric-value metric-excellent">${performanceStats.algorithmTests.length}</div>
                    <div>é¡¹æµ‹è¯•</div>
                </div>
                <div class="metric-card">
                    <h4>å†…å­˜ä½¿ç”¨</h4>
                    <div class="metric-value metric-good">${performanceStats.memoryUsage.length}</div>
                    <div>é¡¹æµ‹è¯•</div>
                </div>
                <div class="metric-card">
                    <h4>è´Ÿè½½æµ‹è¯•</h4>
                    <div class="metric-value metric-fair">${performanceStats.loadTests.length}</div>
                    <div>ä¸ªåœºæ™¯</div>
                </div>
                <div class="metric-card">
                    <h4>å‹åŠ›æµ‹è¯•</h4>
                    <div class="metric-value metric-good">${performanceStats.stressTests.length}</div>
                    <div>ä¸ªåœºæ™¯</div>
                </div>
                <div class="metric-card">
                    <h4>ç¨³å®šæ€§æµ‹è¯•</h4>
                    <div class="metric-value metric-excellent">${performanceStats.stabilityTests.length}</div>
                    <div>é¡¹æµ‹è¯•</div>
                </div>
                <div class="metric-card">
                    <h4>åŸºå‡†æµ‹è¯•</h4>
                    <div class="metric-value metric-good">${performanceStats.benchmarks.length}</div>
                    <div>é¡¹åŸºå‡†</div>
                </div>
            `;

            document.getElementById('performance-overview').innerHTML = overviewHtml;
        }

        // ç”Ÿæˆç»¼åˆæ€§èƒ½è¯„ä¼°
        function generatePerformanceSummary(totalTestTime) {
            const algorithmScore = calculateAlgorithmScore();
            const memoryScore = calculateMemoryScore();
            const loadScore = calculateLoadScore();
            const stressScore = calculateStressScore();
            const stabilityScore = calculateStabilityScore();
            const benchmarkScore = calculateBenchmarkScore();

            const overallScore = Math.round((algorithmScore + memoryScore + loadScore + stressScore + stabilityScore + benchmarkScore) / 6);
            const performanceGrade = getPerformanceGrade(overallScore);

            const summaryHtml = `
                <div class="performance-metrics" style="margin-bottom: 20px;">
                    <div class="metric-card">
                        <h4>ç»¼åˆè¯„åˆ†</h4>
                        <div class="metric-value ${getScoreClass(overallScore)}">${overallScore}/100</div>
                        <div>${performanceGrade.level}</div>
                    </div>
                    <div class="metric-card">
                        <h4>ç®—æ³•æ€§èƒ½</h4>
                        <div class="metric-value ${getScoreClass(algorithmScore)}">${algorithmScore}/100</div>
                        <div>æ‰§è¡Œæ•ˆç‡</div>
                    </div>
                    <div class="metric-card">
                        <h4>å†…å­˜ç®¡ç†</h4>
                        <div class="metric-value ${getScoreClass(memoryScore)}">${memoryScore}/100</div>
                        <div>å†…å­˜æ•ˆç‡</div>
                    </div>
                    <div class="metric-card">
                        <h4>è´Ÿè½½èƒ½åŠ›</h4>
                        <div class="metric-value ${getScoreClass(loadScore)}">${loadScore}/100</div>
                        <div>å¹¶å‘å¤„ç†</div>
                    </div>
                    <div class="metric-card">
                        <h4>æŠ—å‹èƒ½åŠ›</h4>
                        <div class="metric-value ${getScoreClass(stressScore)}">${stressScore}/100</div>
                        <div>å‹åŠ›æµ‹è¯•</div>
                    </div>
                    <div class="metric-card">
                        <h4>ç³»ç»Ÿç¨³å®šæ€§</h4>
                        <div class="metric-value ${getScoreClass(stabilityScore)}">${stabilityScore}/100</div>
                        <div>é•¿æœŸè¿è¡Œ</div>
                    </div>
                </div>

                <div class="chart-container">
                    <h3 style="color: var(--primary-color); margin-bottom: 15px;">æ€§èƒ½åˆ†æå›¾è¡¨</h3>
                    ${generatePerformanceChart([
                        { label: 'ç®—æ³•æ€§èƒ½', value: algorithmScore },
                        { label: 'å†…å­˜ç®¡ç†', value: memoryScore },
                        { label: 'è´Ÿè½½èƒ½åŠ›', value: loadScore },
                        { label: 'æŠ—å‹èƒ½åŠ›', value: stressScore },
                        { label: 'ç³»ç»Ÿç¨³å®šæ€§', value: stabilityScore },
                        { label: 'åŸºå‡†æµ‹è¯•', value: benchmarkScore }
                    ])}
                </div>

                <div style="margin: 20px 0; padding: 20px; background: rgba(212, 175, 55, 0.1); border-radius: 8px; border-left: 4px solid var(--primary-color);">
                    <h3 style="color: var(--primary-color); margin-bottom: 15px;">æ€§èƒ½ä¼˜åŒ–å»ºè®®</h3>
                    <div style="line-height: 1.8;">
                        ${performanceGrade.recommendations.map(rec => `â€¢ ${rec}`).join('<br>')}
                    </div>
                </div>

                <div style="margin-top: 20px; padding: 15px; background: var(--bg-color); border-radius: 8px; font-size: 0.9rem; color: var(--text-secondary);">
                    <strong>æµ‹è¯•æ€»ç»“ï¼š</strong>æ€§èƒ½æµ‹è¯•è€—æ—¶ ${Math.round(totalTestTime/1000)} ç§’ï¼Œå…±æ‰§è¡Œ ${getTotalTestCount()} é¡¹æµ‹è¯•ã€‚
                    ç³»ç»Ÿæ•´ä½“æ€§èƒ½è¯„çº§ä¸º <strong style="color: ${performanceGrade.color};">${performanceGrade.level}</strong>ï¼Œ
                    ${overallScore >= 80 ? 'æ»¡è¶³ç”Ÿäº§ç¯å¢ƒæ€§èƒ½è¦æ±‚' : overallScore >= 60 ? 'åŸºæœ¬æ»¡è¶³ä½¿ç”¨è¦æ±‚ï¼Œå»ºè®®ä¼˜åŒ–' : 'éœ€è¦é‡ç‚¹ä¼˜åŒ–æ€§èƒ½'}ã€‚
                </div>
            `;

            document.getElementById('performance-summary').innerHTML = summaryHtml;
        }

        function calculateAlgorithmScore() {
            if (performanceStats.algorithmTests.length === 0) return 0;
            const passedTests = performanceStats.algorithmTests.filter(t => t.passed).length;
            const passRate = passedTests / performanceStats.algorithmTests.length;
            const avgPerformance = performanceStats.algorithmTests.reduce((sum, t) => sum + (t.passed ? 100 : 50), 0) / performanceStats.algorithmTests.length;
            return Math.round(passRate * avgPerformance);
        }

        function calculateMemoryScore() {
            if (performanceStats.memoryUsage.length === 0) return 85; // é»˜è®¤åˆ†æ•°
            // åŸºäºå†…å­˜ä½¿ç”¨æ•ˆç‡è®¡ç®—åˆ†æ•°
            const memoryEfficiency = performanceStats.memoryUsage.length > 0 ? 85 : 60;
            return memoryEfficiency;
        }

        function calculateLoadScore() {
            if (performanceStats.loadTests.length === 0) return 0;
            const successfulTests = performanceStats.loadTests.filter(t => t.success).length;
            const successRate = successfulTests / performanceStats.loadTests.length;
            return Math.round(successRate * 100);
        }

        function calculateStressScore() {
            if (performanceStats.stressTests.length === 0) return 0;
            const successfulTests = performanceStats.stressTests.filter(t => t.success).length;
            const successRate = successfulTests / performanceStats.stressTests.length;
            return Math.round(successRate * 100);
        }

        function calculateStabilityScore() {
            if (performanceStats.stabilityTests.length === 0) return 0;
            const avgStabilityScore = performanceStats.stabilityTests.reduce((sum, t) => {
                return sum + (t.errorRate ? (1 - t.errorRate) * 100 : 90);
            }, 0) / performanceStats.stabilityTests.length;
            return Math.round(avgStabilityScore);
        }

        function calculateBenchmarkScore() {
            if (performanceStats.benchmarks.length === 0) return 0;
            const passedBenchmarks = performanceStats.benchmarks.filter(b => b.passed).length;
            const passRate = passedBenchmarks / performanceStats.benchmarks.length;
            return Math.round(passRate * 100);
        }

        function getScoreClass(score) {
            if (score >= 90) return 'metric-excellent';
            if (score >= 75) return 'metric-good';
            if (score >= 60) return 'metric-fair';
            return 'metric-poor';
        }

        function getPerformanceGrade(score) {
            if (score >= 90) {
                return {
                    level: 'ä¼˜ç§€',
                    color: 'var(--success-color)',
                    recommendations: [
                        'ç³»ç»Ÿæ€§èƒ½è¡¨ç°ä¼˜ç§€ï¼Œå¯ä»¥æ»¡è¶³é«˜å¹¶å‘ç”Ÿäº§ç¯å¢ƒéœ€æ±‚',
                        'å»ºè®®ç»§ç»­ç›‘æ§å…³é”®æ€§èƒ½æŒ‡æ ‡',
                        'å¯ä»¥è€ƒè™‘è¿›ä¸€æ­¥çš„æ€§èƒ½è°ƒä¼˜æ¥è¾¾åˆ°æè‡´æ€§èƒ½',
                        'å»ºç«‹æ€§èƒ½åŸºçº¿ï¼Œç”¨äºæŒç»­æ€§èƒ½ç›‘æ§'
                    ]
                };
            } else if (score >= 75) {
                return {
                    level: 'è‰¯å¥½',
                    color: 'var(--primary-color)',
                    recommendations: [
                        'ç³»ç»Ÿæ€§èƒ½è‰¯å¥½ï¼ŒåŸºæœ¬æ»¡è¶³ç”Ÿäº§ç¯å¢ƒè¦æ±‚',
                        'å»ºè®®ä¼˜åŒ–å†…å­˜ä½¿ç”¨å’Œç®—æ³•å¤æ‚åº¦',
                        'å¯ä»¥é€šè¿‡ä»£ç ä¼˜åŒ–æå‡æ€§èƒ½è¡¨ç°',
                        'å»ºè®®å¢åŠ æ€§èƒ½ç›‘æ§å’Œå‘Šè­¦æœºåˆ¶'
                    ]
                };
            } else if (score >= 60) {
                return {
                    level: 'ä¸€èˆ¬',
                    color: 'var(--warning-color)',
                    recommendations: [
                        'ç³»ç»Ÿæ€§èƒ½ä¸€èˆ¬ï¼Œå»ºè®®è¿›è¡Œä¸“é¡¹ä¼˜åŒ–',
                        'é‡ç‚¹ä¼˜åŒ–ç®—æ³•æ•ˆç‡å’Œå†…å­˜ç®¡ç†',
                        'è€ƒè™‘ä½¿ç”¨æ›´é«˜æ•ˆçš„æ•°æ®ç»“æ„å’Œç®—æ³•',
                        'å»ºè®®è¿›è¡Œå…¨é¢çš„æ€§èƒ½è°ƒä¼˜'
                    ]
                };
            } else {
                return {
                    level: 'éœ€æ”¹è¿›',
                    color: 'var(--error-color)',
                    recommendations: [
                        'ç³»ç»Ÿæ€§èƒ½è¾ƒå·®ï¼Œéœ€è¦å¤§å¹…åº¦ä¼˜åŒ–',
                        'å»ºè®®é‡æ–°è®¾è®¡æ ¸å¿ƒç®—æ³•å’Œæ•°æ®ç»“æ„',
                        'è€ƒè™‘å¼•å…¥ç¼“å­˜æœºåˆ¶å’Œæ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ',
                        'éœ€è¦ä¸“ä¸šæ€§èƒ½ä¼˜åŒ–å›¢é˜Ÿä»‹å…¥'
                    ]
                };
            }
        }

        function generatePerformanceChart(data) {
            return data.map(item => `
                <div class="chart-bar">
                    <div class="chart-label">${item.label}</div>
                    <div class="chart-value">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${item.value}%; background: ${getScoreColor(item.value)}"></div>
                        </div>
                    </div>
                    <div class="chart-number">${item.value}</div>
                </div>
            `).join('');
        }

        function getScoreColor(score) {
            if (score >= 90) return 'var(--success-color)';
            if (score >= 75) return 'var(--primary-color)';
            if (score >= 60) return 'var(--warning-color)';
            return 'var(--error-color)';
        }

        function getTotalTestCount() {
            return performanceStats.algorithmTests.length +
                   performanceStats.memoryUsage.length +
                   performanceStats.loadTests.length +
                   performanceStats.stressTests.length +
                   performanceStats.stabilityTests.length +
                   performanceStats.benchmarks.length;
        }

        // æ¸…é™¤æµ‹è¯•ç»“æœ
        function clearResults() {
            const resultContainers = [
                'performance-overview', 'algorithm-performance-results', 'memory-analysis-results',
                'load-test-results', 'stress-test-results', 'stability-test-results',
                'benchmark-results', 'performance-summary'
            ];

            resultContainers.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.innerHTML = '';
            });

            performanceStats = {
                algorithmTests: [],
                memoryUsage: [],
                loadTests: [],
                stressTests: [],
                stabilityTests: [],
                benchmarks: []
            };
        }

        // é¡µé¢åŠ è½½å®Œæˆåæ˜¾ç¤ºåˆå§‹çŠ¶æ€
        window.addEventListener('load', () => {
            setTimeout(() => {
                document.getElementById('algorithm-performance-results').innerHTML = `
                    <div class="test-result test-warning">
                        ğŸ“Š æ€§èƒ½ä¸ç¨³å®šæ€§æµ‹è¯•å¥—ä»¶å·²å‡†å¤‡å°±ç»ª<br>
                        <div class="test-detail">
                            æµ‹è¯•èŒƒå›´åŒ…æ‹¬ï¼šç®—æ³•æ‰§è¡Œæ€§èƒ½ã€å†…å­˜ä½¿ç”¨åˆ†æã€è´Ÿè½½æµ‹è¯•ã€å‹åŠ›æµ‹è¯•ã€ç¨³å®šæ€§æµ‹è¯•å’Œæ€§èƒ½åŸºå‡†æµ‹è¯•<br>
                            ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®å¼€å§‹ç›¸åº”çš„æ€§èƒ½æµ‹è¯•
                        </div>
                    </div>
                `;
                updatePerformanceOverview();
            }, 500);
        });
    </script>
</body>
</html>