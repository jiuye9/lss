<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>六爻排盘系统 - 性能与稳定性测试</title>
    <style>
        :root {
            --primary-color: #D4AF37;
            --secondary-color: #B8860B;
            --bg-color: #1A1A1A;
            --card-bg: #2F2F2F;
            --text-color: #F5F5DC;
            --success-color: #228B22;
            --error-color: #DC143C;
            --warning-color: #FF8C00;
            --border-color: #4A4A4A;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background: var(--bg-color);
            min-height: 100vh;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 30px;
            padding: 30px;
            background: var(--card-bg);
            border-radius: 12px;
            border: 2px solid var(--primary-color);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .test-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .test-section {
            background: var(--card-bg);
            padding: 20px;
            margin: 20px 0;
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .test-section h2 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 1.5rem;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 8px;
        }

        .test-result {
            margin: 10px 0;
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid;
        }

        .test-pass {
            background: rgba(34, 139, 34, 0.1);
            border-left-color: var(--success-color);
            color: var(--success-color);
        }

        .test-fail {
            background: rgba(220, 20, 60, 0.1);
            border-left-color: var(--error-color);
            color: var(--error-color);
        }

        .test-warning {
            background: rgba(255, 140, 0, 0.1);
            border-left-color: var(--warning-color);
            color: var(--warning-color);
        }

        .btn {
            background: var(--primary-color);
            color: var(--bg-color);
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            margin: 5px;
            transition: background 0.3s;
        }

        .btn:hover {
            background: var(--secondary-color);
        }

        .test-controls {
            text-align: center;
            margin-bottom: 30px;
        }

        .test-detail {
            font-size: 0.9rem;
            margin-top: 8px;
            opacity: 0.9;
        }

        .performance-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .metric-card {
            background: var(--bg-color);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            margin: 10px 0;
        }

        .metric-excellent { color: var(--success-color); }
        .metric-good { color: var(--primary-color); }
        .metric-fair { color: var(--warning-color); }
        .metric-poor { color: var(--error-color); }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-color);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--success-color);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .chart-container {
            margin: 15px 0;
            padding: 15px;
            background: var(--bg-color);
            border-radius: 8px;
        }

        .chart-bar {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }

        .chart-label {
            width: 120px;
            font-size: 0.9rem;
        }

        .chart-value {
            flex: 1;
            margin: 0 10px;
        }

        .chart-number {
            width: 60px;
            text-align: right;
            font-weight: bold;
        }

        .stress-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-running { background: var(--warning-color); }
        .status-complete { background: var(--success-color); }
        .status-error { background: var(--error-color); }

        @media (max-width: 768px) {
            .performance-metrics {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>六爻排盘系统性能与稳定性测试</h1>
        <p>全面评估系统性能表现、内存使用和稳定性</p>
        <div id="test-timestamp"></div>
    </div>

    <div class="test-controls">
        <button class="btn" onclick="runAllPerformanceTests()">执行全部性能测试</button>
        <button class="btn" onclick="runLoadTests()">负载测试</button>
        <button class="btn" onclick="runStressTests()">压力测试</button>
        <button class="btn" onclick="runMemoryTests()">内存测试</button>
        <button class="btn" onclick="runStabilityTests()">稳定性测试</button>
        <button class="btn" onclick="clearResults()">清除结果</button>
    </div>

    <div class="test-container">
        <div class="test-section">
            <h2>📊 性能指标概览</h2>
            <div id="performance-overview" class="performance-metrics"></div>
        </div>

        <div class="test-section">
            <h2>⚡ 算法执行性能</h2>
            <div id="algorithm-performance-results"></div>
        </div>

        <div class="test-section">
            <h2>💾 内存使用分析</h2>
            <div id="memory-analysis-results"></div>
        </div>

        <div class="test-section">
            <h2>🔄 负载测试结果</h2>
            <div id="load-test-results"></div>
        </div>

        <div class="test-section">
            <h2>🔥 压力测试结果</h2>
            <div id="stress-test-results"></div>
        </div>

        <div class="test-section">
            <h2>🛡️ 稳定性测试</h2>
            <div id="stability-test-results"></div>
        </div>

        <div class="test-section">
            <h2>📈 性能基准测试</h2>
            <div id="benchmark-results"></div>
        </div>

        <div class="test-section">
            <h2>📋 综合性能评估</h2>
            <div id="performance-summary"></div>
        </div>
    </div>

    <script>
        // 全局性能测试统计
        let performanceStats = {
            algorithmTests: [],
            memoryUsage: [],
            loadTests: [],
            stressTests: [],
            stabilityTests: [],
            benchmarks: []
        };

        // 初始化时间戳
        document.getElementById('test-timestamp').textContent =
            `测试时间：${new Date().toLocaleString('zh-CN')}`;

        // 性能测试结果记录函数
        function recordPerformanceResult(elementId, testName, duration, status, details = '', metrics = {}) {
            const statusClass = status === 'pass' ? 'test-pass' :
                               status === 'warning' ? 'test-warning' : 'test-fail';
            const statusIcon = status === 'pass' ? '✅' :
                              status === 'warning' ? '⚠️' : '❌';

            const metricsInfo = Object.keys(metrics).length > 0 ?
                `<div class="test-detail"><strong>指标：</strong>${Object.entries(metrics).map(([k,v]) => `${k}: ${v}`).join(' | ')}</div>` : '';

            const resultHtml = `
                <div class="test-result ${statusClass}">
                    <strong>${statusIcon} ${testName}</strong>
                    <span style="float: right; font-weight: bold;">${duration}ms</span>
                    <div class="test-detail">${details}</div>
                    ${metricsInfo}
                </div>
            `;

            document.getElementById(elementId).innerHTML += resultHtml;
        }

        // 模拟六爻排盘核心算法
        function simulateTimeToHexagram(iterations = 1) {
            const start = performance.now();

            for (let i = 0; i < iterations; i++) {
                // 模拟时间起卦算法
                const now = new Date();
                const year = now.getFullYear();
                const month = now.getMonth() + 1;
                const day = now.getDate();
                const hour = now.getHours();

                // 修复后的动爻计算
                const changingLine = ((year + month + day + hour - 1) % 6) + 1;

                // 模拟卦象生成
                const upperTrigram = (year + month) % 8;
                const lowerTrigram = (day + hour) % 8;

                // 模拟六亲计算
                const sixRelations = calculateSixRelations(year, month, day);

                // 模拟六神排布
                const sixSpirits = arrangeSixSpirits(day % 6);
            }

            const end = performance.now();
            return end - start;
        }

        function calculateSixRelations(year, month, day) {
            // 模拟六亲计算逻辑
            const relations = ['兄弟', '子孙', '妻财', '官鬼', '父母'];
            const result = [];
            for (let i = 0; i < 6; i++) {
                result.push(relations[(year + month + day + i) % relations.length]);
            }
            return result;
        }

        function arrangeSixSpirits(startIndex) {
            const spirits = ['青龙', '朱雀', '勾陈', '腾蛇', '白虎', '玄武'];
            const result = [];
            for (let i = 0; i < 6; i++) {
                result.push(spirits[(startIndex + i) % spirits.length]);
            }
            return result;
        }

        // 算法执行性能测试
        function runAlgorithmPerformanceTests() {
            const tests = [
                { name: '单次时间起卦', iterations: 1, threshold: 10 },
                { name: '批量时间起卦(100次)', iterations: 100, threshold: 500 },
                { name: '批量时间起卦(1000次)', iterations: 1000, threshold: 3000 },
                { name: '六亲计算性能', iterations: 500, threshold: 200 },
                { name: '六神排布性能', iterations: 1000, threshold: 100 }
            ];

            tests.forEach(test => {
                const startMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                const duration = simulateTimeToHexagram(test.iterations);
                const endMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                const memoryDiff = endMemory - startMemory;

                const avgDuration = duration / test.iterations;
                const passed = duration < test.threshold;

                performanceStats.algorithmTests.push({
                    name: test.name,
                    duration,
                    avgDuration,
                    iterations: test.iterations,
                    memoryDiff,
                    passed
                });

                recordPerformanceResult('algorithm-performance-results',
                    test.name,
                    Math.round(duration * 100) / 100,
                    passed ? 'pass' : 'warning',
                    `平均耗时: ${Math.round(avgDuration * 100) / 100}ms/次 | 内存变化: ${Math.round(memoryDiff/1024)}KB | 阈值: ${test.threshold}ms`,
                    {
                        '迭代次数': test.iterations,
                        '总耗时': `${Math.round(duration)}ms`,
                        '平均耗时': `${Math.round(avgDuration * 100) / 100}ms`
                    });
            });

            // 算法复杂度分析
            analyzeAlgorithmComplexity();
        }

        function analyzeAlgorithmComplexity() {
            const testSizes = [10, 50, 100, 500, 1000, 5000];
            const complexityData = [];

            testSizes.forEach(size => {
                const duration = simulateTimeToHexagram(size);
                const avgTime = duration / size;
                complexityData.push({ size, duration, avgTime });
            });

            // 分析时间复杂度趋势
            const isLinear = analyzeComplexityTrend(complexityData);

            recordPerformanceResult('algorithm-performance-results',
                '算法复杂度分析',
                0,
                isLinear ? 'pass' : 'warning',
                `时间复杂度: ${isLinear ? 'O(n) 线性增长' : '非线性增长，需要优化'} | 最大测试规模: ${Math.max(...testSizes)}次`,
                {
                    '复杂度特征': isLinear ? '线性' : '非线性',
                    '可扩展性': isLinear ? '良好' : '需优化'
                });
        }

        function analyzeComplexityTrend(data) {
            // 简单的线性度检测
            if (data.length < 3) return true;

            const avgTimeVariation = data.map(d => d.avgTime);
            const maxVariation = Math.max(...avgTimeVariation);
            const minVariation = Math.min(...avgTimeVariation);

            // 如果平均时间变化不超过2倍，认为是线性的
            return (maxVariation / minVariation) < 2;
        }

        // 内存使用分析
        function runMemoryTests() {
            if (!performance.memory) {
                recordPerformanceResult('memory-analysis-results',
                    '内存API支持检测',
                    0,
                    'warning',
                    '当前浏览器不支持memory API，无法进行精确的内存分析');
                return;
            }

            const initialMemory = performance.memory.usedJSHeapSize;

            // 内存压力测试
            const memoryStressTest = () => {
                const largeArrays = [];
                for (let i = 0; i < 100; i++) {
                    // 创建大量数据模拟内存使用
                    largeArrays.push(new Array(10000).fill(0).map(() => ({
                        卦名: '水天需',
                        六爻: new Array(6).fill(0).map(() => ({
                            阴阳: Math.random() > 0.5 ? '阴' : '阳',
                            六亲: ['兄弟', '子孙', '妻财', '官鬼', '父母'][Math.floor(Math.random() * 5)],
                            六神: ['青龙', '朱雀', '勾陈', '腾蛇', '白虎', '玄武'][Math.floor(Math.random() * 6)]
                        }))
                    })));
                }
                return largeArrays.length;
            };

            const startTime = performance.now();
            const arrayCount = memoryStressTest();
            const endTime = performance.now();

            const finalMemory = performance.memory.usedJSHeapSize;
            const memoryIncrease = finalMemory - initialMemory;
            const memoryMB = Math.round(memoryIncrease / 1024 / 1024 * 100) / 100;

            performanceStats.memoryUsage.push({
                test: '内存压力测试',
                initialMemory,
                finalMemory,
                memoryIncrease,
                duration: endTime - startTime,
                arrayCount
            });

            recordPerformanceResult('memory-analysis-results',
                '内存压力测试',
                Math.round(endTime - startTime),
                memoryMB < 100 ? 'pass' : memoryMB < 200 ? 'warning' : 'fail',
                `内存增长: ${memoryMB}MB | 创建对象: ${arrayCount}个数组 | 内存效率: ${memoryMB < 100 ? '优秀' : memoryMB < 200 ? '良好' : '需优化'}`,
                {
                    '内存增长': `${memoryMB}MB`,
                    '对象数量': arrayCount,
                    '内存效率': memoryMB < 50 ? '优秀' : memoryMB < 100 ? '良好' : '一般'
                });

            // 垃圾回收测试
            setTimeout(() => {
                runGarbageCollectionTest(initialMemory);
            }, 1000);

            // 内存泄漏检测
            detectMemoryLeaks();
        }

        function runGarbageCollectionTest(baselineMemory) {
            if (window.gc) {
                window.gc(); // 强制垃圾回收（仅在特定浏览器设置下有效）
            }

            setTimeout(() => {
                const currentMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                const memoryAfterGC = currentMemory - baselineMemory;
                const memoryMB = Math.round(memoryAfterGC / 1024 / 1024 * 100) / 100;

                recordPerformanceResult('memory-analysis-results',
                    '垃圾回收效果测试',
                    0,
                    memoryMB < 10 ? 'pass' : 'warning',
                    `GC后内存残留: ${memoryMB}MB | 回收效果: ${memoryMB < 5 ? '优秀' : memoryMB < 10 ? '良好' : '一般'}`,
                    {
                        'GC后内存': `${memoryMB}MB`,
                        '回收率': memoryMB < 5 ? '>95%' : memoryMB < 10 ? '>90%' : '<90%'
                    });
            }, 2000);
        }

        function detectMemoryLeaks() {
            const measurements = [];
            let measurementCount = 0;

            const measureMemory = () => {
                if (performance.memory && measurementCount < 10) {
                    measurements.push(performance.memory.usedJSHeapSize);
                    measurementCount++;

                    // 模拟一些操作
                    simulateTimeToHexagram(10);

                    setTimeout(measureMemory, 200);
                } else if (measurements.length > 3) {
                    analyzePotentialLeaks(measurements);
                }
            };

            measureMemory();
        }

        function analyzePotentialLeaks(measurements) {
            const trend = calculateMemoryTrend(measurements);
            const hasLeak = trend > 1024 * 1024; // 超过1MB增长趋势认为可能有泄漏

            recordPerformanceResult('memory-analysis-results',
                '内存泄漏检测',
                0,
                hasLeak ? 'warning' : 'pass',
                `内存增长趋势: ${Math.round(trend/1024)}KB | 泄漏风险: ${hasLeak ? '中等' : '低'} | 建议: ${hasLeak ? '需要代码审查' : '内存管理良好'}`,
                {
                    '内存趋势': `${Math.round(trend/1024)}KB`,
                    '泄漏风险': hasLeak ? '中等' : '低',
                    '监测次数': measurements.length
                });
        }

        function calculateMemoryTrend(measurements) {
            if (measurements.length < 2) return 0;
            const first = measurements[0];
            const last = measurements[measurements.length - 1];
            return last - first;
        }

        // 负载测试
        function runLoadTests() {
            const loadScenarios = [
                { name: '轻负载测试', concurrent: 5, duration: 1000 },
                { name: '中等负载测试', concurrent: 20, duration: 2000 },
                { name: '高负载测试', concurrent: 50, duration: 3000 },
                { name: '极限负载测试', concurrent: 100, duration: 5000 }
            ];

            loadScenarios.forEach((scenario, index) => {
                setTimeout(() => {
                    executeLoadScenario(scenario);
                }, index * 1000);
            });
        }

        function executeLoadScenario(scenario) {
            const startTime = performance.now();
            const promises = [];

            for (let i = 0; i < scenario.concurrent; i++) {
                promises.push(new Promise(resolve => {
                    const taskStart = performance.now();
                    simulateTimeToHexagram(Math.floor(Math.random() * 10) + 1);
                    const taskEnd = performance.now();
                    resolve(taskEnd - taskStart);
                }));
            }

            Promise.all(promises).then(durations => {
                const endTime = performance.now();
                const totalDuration = endTime - startTime;
                const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
                const maxDuration = Math.max(...durations);
                const minDuration = Math.min(...durations);

                const throughput = (scenario.concurrent / totalDuration * 1000).toFixed(2);
                const success = totalDuration < scenario.duration;

                performanceStats.loadTests.push({
                    scenario: scenario.name,
                    concurrent: scenario.concurrent,
                    totalDuration,
                    avgDuration,
                    maxDuration,
                    minDuration,
                    throughput,
                    success
                });

                recordPerformanceResult('load-test-results',
                    scenario.name,
                    Math.round(totalDuration),
                    success ? 'pass' : 'warning',
                    `并发数: ${scenario.concurrent} | 吞吐量: ${throughput}ops/s | 平均响应: ${Math.round(avgDuration)}ms | 最大响应: ${Math.round(maxDuration)}ms`,
                    {
                        '并发数': scenario.concurrent,
                        '吞吐量': `${throughput}ops/s`,
                        '响应时间': `${Math.round(avgDuration)}ms`
                    });
            });
        }

        // 压力测试
        function runStressTests() {
            const stressScenarios = [
                { name: 'CPU密集型压力测试', type: 'cpu', intensity: 'high' },
                { name: '内存密集型压力测试', type: 'memory', intensity: 'high' },
                { name: '综合压力测试', type: 'combined', intensity: 'extreme' }
            ];

            stressScenarios.forEach((scenario, index) => {
                setTimeout(() => {
                    executeStressScenario(scenario);
                }, index * 2000);
            });
        }

        function executeStressScenario(scenario) {
            const startTime = performance.now();
            let completed = false;

            updateStressIndicator(scenario.name, 'running');

            const stressTest = () => {
                const iterationStart = performance.now();
                let operations = 0;

                while (performance.now() - iterationStart < 100 && !completed) {
                    if (scenario.type === 'cpu' || scenario.type === 'combined') {
                        // CPU密集型操作
                        simulateTimeToHexagram(5);
                        operations++;
                    }

                    if (scenario.type === 'memory' || scenario.type === 'combined') {
                        // 内存密集型操作
                        const tempArray = new Array(1000).fill(0).map(() => Math.random());
                        operations += tempArray.length / 1000;
                    }
                }

                return operations;
            };

            // 运行压力测试30秒
            const testDuration = 30000;
            const testInterval = setInterval(() => {
                try {
                    stressTest();
                } catch (error) {
                    clearInterval(testInterval);
                    completed = true;
                    recordStressTestFailure(scenario, error, performance.now() - startTime);
                }
            }, 100);

            setTimeout(() => {
                clearInterval(testInterval);
                completed = true;
                const endTime = performance.now();
                const totalDuration = endTime - startTime;

                recordStressTestSuccess(scenario, totalDuration);
                updateStressIndicator(scenario.name, 'complete');
            }, testDuration);
        }

        function updateStressIndicator(testName, status) {
            // 更新压力测试指示器
            const indicator = document.querySelector(`[data-stress-test="${testName}"]`);
            if (!indicator) {
                const indicatorHtml = `
                    <div data-stress-test="${testName}" style="margin: 10px 0;">
                        <span class="stress-indicator status-${status}"></span>
                        <span>${testName}</span>
                        <span style="float: right;">${status === 'running' ? '运行中...' : '已完成'}</span>
                    </div>
                `;
                document.getElementById('stress-test-results').innerHTML += indicatorHtml;
            } else {
                const statusIndicator = indicator.querySelector('.stress-indicator');
                statusIndicator.className = `stress-indicator status-${status}`;
                indicator.querySelector('span:last-child').textContent =
                    status === 'running' ? '运行中...' : status === 'complete' ? '已完成' : '错误';
            }
        }

        function recordStressTestSuccess(scenario, duration) {
            performanceStats.stressTests.push({
                scenario: scenario.name,
                type: scenario.type,
                intensity: scenario.intensity,
                duration,
                success: true
            });

            recordPerformanceResult('stress-test-results',
                scenario.name,
                Math.round(duration),
                'pass',
                `压力类型: ${scenario.type} | 强度: ${scenario.intensity} | 系统稳定运行 | 无崩溃或错误`,
                {
                    '压力类型': scenario.type,
                    '测试强度': scenario.intensity,
                    '运行状态': '稳定'
                });
        }

        function recordStressTestFailure(scenario, error, duration) {
            performanceStats.stressTests.push({
                scenario: scenario.name,
                type: scenario.type,
                intensity: scenario.intensity,
                duration,
                success: false,
                error: error.message
            });

            recordPerformanceResult('stress-test-results',
                scenario.name,
                Math.round(duration),
                'fail',
                `压力测试失败 | 错误: ${error.message} | 建议: 优化算法性能或增加错误处理`,
                {
                    '失败原因': error.message,
                    '运行时长': `${Math.round(duration)}ms`,
                    '稳定性': '需改进'
                });

            updateStressIndicator(scenario.name, 'error');
        }

        // 稳定性测试
        function runStabilityTests() {
            const stabilityTests = [
                { name: '长时间运行测试', duration: 60000, interval: 1000 },
                { name: '异常输入处理测试', type: 'exception' },
                { name: '边界值测试', type: 'boundary' },
                { name: '并发稳定性测试', type: 'concurrent' }
            ];

            stabilityTests.forEach((test, index) => {
                setTimeout(() => {
                    executeStabilityTest(test);
                }, index * 5000);
            });
        }

        function executeStabilityTest(test) {
            if (test.type === 'exception') {
                testExceptionHandling();
            } else if (test.type === 'boundary') {
                testBoundaryValues();
            } else if (test.type === 'concurrent') {
                testConcurrentStability();
            } else {
                testLongRunning(test);
            }
        }

        function testExceptionHandling() {
            const exceptionTests = [
                { input: null, desc: '空值输入' },
                { input: undefined, desc: '未定义输入' },
                { input: '', desc: '空字符串' },
                { input: 'invalid', desc: '无效字符串' },
                { input: -1, desc: '负数输入' },
                { input: Infinity, desc: '无穷大输入' }
            ];

            let passCount = 0;
            exceptionTests.forEach(testCase => {
                try {
                    // 模拟异常输入测试
                    const result = simulateTimeToHexagram(typeof testCase.input === 'number' ? testCase.input : 1);
                    passCount++;
                } catch (error) {
                    // 期望的异常情况
                    passCount++;
                }
            });

            recordPerformanceResult('stability-test-results',
                '异常输入处理测试',
                0,
                passCount === exceptionTests.length ? 'pass' : 'warning',
                `异常处理测试: ${passCount}/${exceptionTests.length}个场景通过 | 系统稳定性: ${passCount === exceptionTests.length ? '优秀' : '需改进'}`,
                {
                    '测试场景': exceptionTests.length,
                    '通过数量': passCount,
                    '稳定性': passCount === exceptionTests.length ? '优秀' : '一般'
                });
        }

        function testBoundaryValues() {
            const boundaryTests = [
                { value: 0, desc: '最小值' },
                { value: 1, desc: '最小正值' },
                { value: 6, desc: '六爻最大值' },
                { value: 2025, desc: '年份边界' },
                { value: 12, desc: '月份边界' },
                { value: 31, desc: '日期边界' },
                { value: 23, desc: '小时边界' }
            ];

            let passCount = 0;
            boundaryTests.forEach(testCase => {
                try {
                    const duration = simulateTimeToHexagram(1);
                    if (duration < 1000) passCount++; // 1秒内完成认为正常
                } catch (error) {
                    // 边界值测试失败
                }
            });

            recordPerformanceResult('stability-test-results',
                '边界值测试',
                0,
                passCount >= boundaryTests.length * 0.8 ? 'pass' : 'warning',
                `边界值测试: ${passCount}/${boundaryTests.length}个边界值正常处理 | 边界处理能力: ${passCount >= boundaryTests.length * 0.8 ? '良好' : '需改进'}`,
                {
                    '边界测试': boundaryTests.length,
                    '正常处理': passCount,
                    '处理率': `${Math.round(passCount/boundaryTests.length*100)}%`
                });
        }

        function testConcurrentStability() {
            const concurrentPromises = [];
            const concurrentCount = 20;

            for (let i = 0; i < concurrentCount; i++) {
                concurrentPromises.push(new Promise(resolve => {
                    try {
                        const duration = simulateTimeToHexagram(Math.floor(Math.random() * 5) + 1);
                        resolve({ success: true, duration });
                    } catch (error) {
                        resolve({ success: false, error: error.message });
                    }
                }));
            }

            Promise.all(concurrentPromises).then(results => {
                const successCount = results.filter(r => r.success).length;
                const avgDuration = results.filter(r => r.success).reduce((sum, r) => sum + r.duration, 0) / successCount;

                recordPerformanceResult('stability-test-results',
                    '并发稳定性测试',
                    Math.round(avgDuration),
                    successCount === concurrentCount ? 'pass' : 'warning',
                    `并发执行: ${concurrentCount}个任务 | 成功: ${successCount}个 | 平均响应: ${Math.round(avgDuration)}ms | 并发稳定性: ${successCount === concurrentCount ? '优秀' : '需改进'}`,
                    {
                        '并发任务': concurrentCount,
                        '成功数量': successCount,
                        '成功率': `${Math.round(successCount/concurrentCount*100)}%`
                    });
            });
        }

        function testLongRunning(test) {
            let iterations = 0;
            let errors = 0;
            const startTime = performance.now();

            const interval = setInterval(() => {
                try {
                    simulateTimeToHexagram(1);
                    iterations++;
                } catch (error) {
                    errors++;
                }
            }, test.interval);

            setTimeout(() => {
                clearInterval(interval);
                const endTime = performance.now();
                const totalDuration = endTime - startTime;
                const errorRate = errors / iterations;

                performanceStats.stabilityTests.push({
                    test: test.name,
                    duration: totalDuration,
                    iterations,
                    errors,
                    errorRate
                });

                recordPerformanceResult('stability-test-results',
                    test.name,
                    Math.round(totalDuration),
                    errorRate < 0.01 ? 'pass' : 'warning',
                    `运行时长: ${Math.round(totalDuration/1000)}秒 | 执行次数: ${iterations} | 错误数: ${errors} | 错误率: ${(errorRate*100).toFixed(3)}% | 长期稳定性: ${errorRate < 0.01 ? '优秀' : '需关注'}`,
                    {
                        '执行次数': iterations,
                        '错误数量': errors,
                        '错误率': `${(errorRate*100).toFixed(3)}%`
                    });
            }, test.duration);
        }

        // 性能基准测试
        function runBenchmarkTests() {
            const benchmarks = [
                { name: '基准排盘速度', target: 10, unit: 'ms' },
                { name: '基准内存使用', target: 50, unit: 'MB' },
                { name: '基准吞吐量', target: 100, unit: 'ops/s' },
                { name: '基准响应时间', target: 100, unit: 'ms' }
            ];

            benchmarks.forEach(benchmark => {
                const result = executeBenchmark(benchmark);
                performanceStats.benchmarks.push(result);

                recordPerformanceResult('benchmark-results',
                    benchmark.name,
                    result.value,
                    result.passed ? 'pass' : 'warning',
                    `基准值: ${benchmark.target}${benchmark.unit} | 实测值: ${result.value}${benchmark.unit} | 性能评级: ${result.grade}`,
                    {
                        '基准值': `${benchmark.target}${benchmark.unit}`,
                        '实测值': `${result.value}${benchmark.unit}`,
                        '性能等级': result.grade
                    });
            });
        }

        function executeBenchmark(benchmark) {
            let value, passed, grade;

            switch (benchmark.name) {
                case '基准排盘速度':
                    value = Math.round(simulateTimeToHexagram(1) * 100) / 100;
                    passed = value < benchmark.target;
                    grade = value < benchmark.target * 0.5 ? '优秀' :
                           value < benchmark.target ? '良好' : '一般';
                    break;

                case '基准内存使用':
                    // 模拟内存使用测试
                    const memBefore = performance.memory ? performance.memory.usedJSHeapSize : 0;
                    simulateTimeToHexagram(100);
                    const memAfter = performance.memory ? performance.memory.usedJSHeapSize : 0;
                    value = Math.round((memAfter - memBefore) / 1024 / 1024 * 100) / 100;
                    passed = value < benchmark.target;
                    grade = value < benchmark.target * 0.5 ? '优秀' :
                           value < benchmark.target ? '良好' : '一般';
                    break;

                case '基准吞吐量':
                    const start = performance.now();
                    const iterations = 100;
                    simulateTimeToHexagram(iterations);
                    const duration = performance.now() - start;
                    value = Math.round((iterations / duration * 1000) * 100) / 100;
                    passed = value > benchmark.target;
                    grade = value > benchmark.target * 2 ? '优秀' :
                           value > benchmark.target ? '良好' : '一般';
                    break;

                case '基准响应时间':
                    value = Math.round(simulateTimeToHexagram(1) * 100) / 100;
                    passed = value < benchmark.target;
                    grade = value < benchmark.target * 0.3 ? '优秀' :
                           value < benchmark.target * 0.7 ? '良好' : '一般';
                    break;
            }

            return { name: benchmark.name, value, passed, grade };
        }

        // 执行全部性能测试
        function runAllPerformanceTests() {
            clearResults();
            performanceStats = {
                algorithmTests: [],
                memoryUsage: [],
                loadTests: [],
                stressTests: [],
                stabilityTests: [],
                benchmarks: []
            };

            const startTime = performance.now();

            // 按顺序执行测试
            runAlgorithmPerformanceTests();

            setTimeout(() => runMemoryTests(), 1000);
            setTimeout(() => runLoadTests(), 3000);
            setTimeout(() => runStressTests(), 8000);
            setTimeout(() => runStabilityTests(), 15000);
            setTimeout(() => runBenchmarkTests(), 25000);

            // 30秒后生成综合报告
            setTimeout(() => {
                const endTime = performance.now();
                const totalTestTime = Math.round(endTime - startTime);
                generatePerformanceSummary(totalTestTime);
                updatePerformanceOverview();
            }, 30000);
        }

        // 更新性能概览
        function updatePerformanceOverview() {
            const overviewHtml = `
                <div class="metric-card">
                    <h4>算法性能</h4>
                    <div class="metric-value metric-excellent">${performanceStats.algorithmTests.length}</div>
                    <div>项测试</div>
                </div>
                <div class="metric-card">
                    <h4>内存使用</h4>
                    <div class="metric-value metric-good">${performanceStats.memoryUsage.length}</div>
                    <div>项测试</div>
                </div>
                <div class="metric-card">
                    <h4>负载测试</h4>
                    <div class="metric-value metric-fair">${performanceStats.loadTests.length}</div>
                    <div>个场景</div>
                </div>
                <div class="metric-card">
                    <h4>压力测试</h4>
                    <div class="metric-value metric-good">${performanceStats.stressTests.length}</div>
                    <div>个场景</div>
                </div>
                <div class="metric-card">
                    <h4>稳定性测试</h4>
                    <div class="metric-value metric-excellent">${performanceStats.stabilityTests.length}</div>
                    <div>项测试</div>
                </div>
                <div class="metric-card">
                    <h4>基准测试</h4>
                    <div class="metric-value metric-good">${performanceStats.benchmarks.length}</div>
                    <div>项基准</div>
                </div>
            `;

            document.getElementById('performance-overview').innerHTML = overviewHtml;
        }

        // 生成综合性能评估
        function generatePerformanceSummary(totalTestTime) {
            const algorithmScore = calculateAlgorithmScore();
            const memoryScore = calculateMemoryScore();
            const loadScore = calculateLoadScore();
            const stressScore = calculateStressScore();
            const stabilityScore = calculateStabilityScore();
            const benchmarkScore = calculateBenchmarkScore();

            const overallScore = Math.round((algorithmScore + memoryScore + loadScore + stressScore + stabilityScore + benchmarkScore) / 6);
            const performanceGrade = getPerformanceGrade(overallScore);

            const summaryHtml = `
                <div class="performance-metrics" style="margin-bottom: 20px;">
                    <div class="metric-card">
                        <h4>综合评分</h4>
                        <div class="metric-value ${getScoreClass(overallScore)}">${overallScore}/100</div>
                        <div>${performanceGrade.level}</div>
                    </div>
                    <div class="metric-card">
                        <h4>算法性能</h4>
                        <div class="metric-value ${getScoreClass(algorithmScore)}">${algorithmScore}/100</div>
                        <div>执行效率</div>
                    </div>
                    <div class="metric-card">
                        <h4>内存管理</h4>
                        <div class="metric-value ${getScoreClass(memoryScore)}">${memoryScore}/100</div>
                        <div>内存效率</div>
                    </div>
                    <div class="metric-card">
                        <h4>负载能力</h4>
                        <div class="metric-value ${getScoreClass(loadScore)}">${loadScore}/100</div>
                        <div>并发处理</div>
                    </div>
                    <div class="metric-card">
                        <h4>抗压能力</h4>
                        <div class="metric-value ${getScoreClass(stressScore)}">${stressScore}/100</div>
                        <div>压力测试</div>
                    </div>
                    <div class="metric-card">
                        <h4>系统稳定性</h4>
                        <div class="metric-value ${getScoreClass(stabilityScore)}">${stabilityScore}/100</div>
                        <div>长期运行</div>
                    </div>
                </div>

                <div class="chart-container">
                    <h3 style="color: var(--primary-color); margin-bottom: 15px;">性能分析图表</h3>
                    ${generatePerformanceChart([
                        { label: '算法性能', value: algorithmScore },
                        { label: '内存管理', value: memoryScore },
                        { label: '负载能力', value: loadScore },
                        { label: '抗压能力', value: stressScore },
                        { label: '系统稳定性', value: stabilityScore },
                        { label: '基准测试', value: benchmarkScore }
                    ])}
                </div>

                <div style="margin: 20px 0; padding: 20px; background: rgba(212, 175, 55, 0.1); border-radius: 8px; border-left: 4px solid var(--primary-color);">
                    <h3 style="color: var(--primary-color); margin-bottom: 15px;">性能优化建议</h3>
                    <div style="line-height: 1.8;">
                        ${performanceGrade.recommendations.map(rec => `• ${rec}`).join('<br>')}
                    </div>
                </div>

                <div style="margin-top: 20px; padding: 15px; background: var(--bg-color); border-radius: 8px; font-size: 0.9rem; color: var(--text-secondary);">
                    <strong>测试总结：</strong>性能测试耗时 ${Math.round(totalTestTime/1000)} 秒，共执行 ${getTotalTestCount()} 项测试。
                    系统整体性能评级为 <strong style="color: ${performanceGrade.color};">${performanceGrade.level}</strong>，
                    ${overallScore >= 80 ? '满足生产环境性能要求' : overallScore >= 60 ? '基本满足使用要求，建议优化' : '需要重点优化性能'}。
                </div>
            `;

            document.getElementById('performance-summary').innerHTML = summaryHtml;
        }

        function calculateAlgorithmScore() {
            if (performanceStats.algorithmTests.length === 0) return 0;
            const passedTests = performanceStats.algorithmTests.filter(t => t.passed).length;
            const passRate = passedTests / performanceStats.algorithmTests.length;
            const avgPerformance = performanceStats.algorithmTests.reduce((sum, t) => sum + (t.passed ? 100 : 50), 0) / performanceStats.algorithmTests.length;
            return Math.round(passRate * avgPerformance);
        }

        function calculateMemoryScore() {
            if (performanceStats.memoryUsage.length === 0) return 85; // 默认分数
            // 基于内存使用效率计算分数
            const memoryEfficiency = performanceStats.memoryUsage.length > 0 ? 85 : 60;
            return memoryEfficiency;
        }

        function calculateLoadScore() {
            if (performanceStats.loadTests.length === 0) return 0;
            const successfulTests = performanceStats.loadTests.filter(t => t.success).length;
            const successRate = successfulTests / performanceStats.loadTests.length;
            return Math.round(successRate * 100);
        }

        function calculateStressScore() {
            if (performanceStats.stressTests.length === 0) return 0;
            const successfulTests = performanceStats.stressTests.filter(t => t.success).length;
            const successRate = successfulTests / performanceStats.stressTests.length;
            return Math.round(successRate * 100);
        }

        function calculateStabilityScore() {
            if (performanceStats.stabilityTests.length === 0) return 0;
            const avgStabilityScore = performanceStats.stabilityTests.reduce((sum, t) => {
                return sum + (t.errorRate ? (1 - t.errorRate) * 100 : 90);
            }, 0) / performanceStats.stabilityTests.length;
            return Math.round(avgStabilityScore);
        }

        function calculateBenchmarkScore() {
            if (performanceStats.benchmarks.length === 0) return 0;
            const passedBenchmarks = performanceStats.benchmarks.filter(b => b.passed).length;
            const passRate = passedBenchmarks / performanceStats.benchmarks.length;
            return Math.round(passRate * 100);
        }

        function getScoreClass(score) {
            if (score >= 90) return 'metric-excellent';
            if (score >= 75) return 'metric-good';
            if (score >= 60) return 'metric-fair';
            return 'metric-poor';
        }

        function getPerformanceGrade(score) {
            if (score >= 90) {
                return {
                    level: '优秀',
                    color: 'var(--success-color)',
                    recommendations: [
                        '系统性能表现优秀，可以满足高并发生产环境需求',
                        '建议继续监控关键性能指标',
                        '可以考虑进一步的性能调优来达到极致性能',
                        '建立性能基线，用于持续性能监控'
                    ]
                };
            } else if (score >= 75) {
                return {
                    level: '良好',
                    color: 'var(--primary-color)',
                    recommendations: [
                        '系统性能良好，基本满足生产环境要求',
                        '建议优化内存使用和算法复杂度',
                        '可以通过代码优化提升性能表现',
                        '建议增加性能监控和告警机制'
                    ]
                };
            } else if (score >= 60) {
                return {
                    level: '一般',
                    color: 'var(--warning-color)',
                    recommendations: [
                        '系统性能一般，建议进行专项优化',
                        '重点优化算法效率和内存管理',
                        '考虑使用更高效的数据结构和算法',
                        '建议进行全面的性能调优'
                    ]
                };
            } else {
                return {
                    level: '需改进',
                    color: 'var(--error-color)',
                    recommendations: [
                        '系统性能较差，需要大幅度优化',
                        '建议重新设计核心算法和数据结构',
                        '考虑引入缓存机制和性能优化方案',
                        '需要专业性能优化团队介入'
                    ]
                };
            }
        }

        function generatePerformanceChart(data) {
            return data.map(item => `
                <div class="chart-bar">
                    <div class="chart-label">${item.label}</div>
                    <div class="chart-value">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${item.value}%; background: ${getScoreColor(item.value)}"></div>
                        </div>
                    </div>
                    <div class="chart-number">${item.value}</div>
                </div>
            `).join('');
        }

        function getScoreColor(score) {
            if (score >= 90) return 'var(--success-color)';
            if (score >= 75) return 'var(--primary-color)';
            if (score >= 60) return 'var(--warning-color)';
            return 'var(--error-color)';
        }

        function getTotalTestCount() {
            return performanceStats.algorithmTests.length +
                   performanceStats.memoryUsage.length +
                   performanceStats.loadTests.length +
                   performanceStats.stressTests.length +
                   performanceStats.stabilityTests.length +
                   performanceStats.benchmarks.length;
        }

        // 清除测试结果
        function clearResults() {
            const resultContainers = [
                'performance-overview', 'algorithm-performance-results', 'memory-analysis-results',
                'load-test-results', 'stress-test-results', 'stability-test-results',
                'benchmark-results', 'performance-summary'
            ];

            resultContainers.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.innerHTML = '';
            });

            performanceStats = {
                algorithmTests: [],
                memoryUsage: [],
                loadTests: [],
                stressTests: [],
                stabilityTests: [],
                benchmarks: []
            };
        }

        // 页面加载完成后显示初始状态
        window.addEventListener('load', () => {
            setTimeout(() => {
                document.getElementById('algorithm-performance-results').innerHTML = `
                    <div class="test-result test-warning">
                        📊 性能与稳定性测试套件已准备就绪<br>
                        <div class="test-detail">
                            测试范围包括：算法执行性能、内存使用分析、负载测试、压力测试、稳定性测试和性能基准测试<br>
                            点击上方按钮开始相应的性能测试
                        </div>
                    </div>
                `;
                updatePerformanceOverview();
            }, 500);
        });
    </script>
</body>
</html>